// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net-protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_2dprotocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_net_2dprotocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_net_2dprotocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_net_2dprotocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_net_2dprotocol_2eproto;
class ChassisStatus;
struct ChassisStatusDefaultTypeInternal;
extern ChassisStatusDefaultTypeInternal _ChassisStatus_default_instance_;
class CmdPacket;
struct CmdPacketDefaultTypeInternal;
extern CmdPacketDefaultTypeInternal _CmdPacket_default_instance_;
class ConfigMessage;
struct ConfigMessageDefaultTypeInternal;
extern ConfigMessageDefaultTypeInternal _ConfigMessage_default_instance_;
class DataFrame;
struct DataFrameDefaultTypeInternal;
extern DataFrameDefaultTypeInternal _DataFrame_default_instance_;
class DataPacket;
struct DataPacketDefaultTypeInternal;
extern DataPacketDefaultTypeInternal _DataPacket_default_instance_;
class DevModeValidation;
struct DevModeValidationDefaultTypeInternal;
extern DevModeValidationDefaultTypeInternal _DevModeValidation_default_instance_;
class LogicInterruptMessage;
struct LogicInterruptMessageDefaultTypeInternal;
extern LogicInterruptMessageDefaultTypeInternal _LogicInterruptMessage_default_instance_;
class LogicMessage;
struct LogicMessageDefaultTypeInternal;
extern LogicMessageDefaultTypeInternal _LogicMessage_default_instance_;
class RawCommand;
struct RawCommandDefaultTypeInternal;
extern RawCommandDefaultTypeInternal _RawCommand_default_instance_;
class SensorConfig;
struct SensorConfigDefaultTypeInternal;
extern SensorConfigDefaultTypeInternal _SensorConfig_default_instance_;
class SensorField;
struct SensorFieldDefaultTypeInternal;
extern SensorFieldDefaultTypeInternal _SensorField_default_instance_;
class SensorLed;
struct SensorLedDefaultTypeInternal;
extern SensorLedDefaultTypeInternal _SensorLed_default_instance_;
class SensorState;
struct SensorStateDefaultTypeInternal;
extern SensorStateDefaultTypeInternal _SensorState_default_instance_;
class SensorStatus;
struct SensorStatusDefaultTypeInternal;
extern SensorStatusDefaultTypeInternal _SensorStatus_default_instance_;
class StatusPacket;
struct StatusPacketDefaultTypeInternal;
extern StatusPacketDefaultTypeInternal _StatusPacket_default_instance_;
class SystemStatusMessage;
struct SystemStatusMessageDefaultTypeInternal;
extern SystemStatusMessageDefaultTypeInternal _SystemStatusMessage_default_instance_;
class WaveMessage;
struct WaveMessageDefaultTypeInternal;
extern WaveMessageDefaultTypeInternal _WaveMessage_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ChassisStatus* Arena::CreateMaybeMessage<::ChassisStatus>(Arena*);
template<> ::CmdPacket* Arena::CreateMaybeMessage<::CmdPacket>(Arena*);
template<> ::ConfigMessage* Arena::CreateMaybeMessage<::ConfigMessage>(Arena*);
template<> ::DataFrame* Arena::CreateMaybeMessage<::DataFrame>(Arena*);
template<> ::DataPacket* Arena::CreateMaybeMessage<::DataPacket>(Arena*);
template<> ::DevModeValidation* Arena::CreateMaybeMessage<::DevModeValidation>(Arena*);
template<> ::LogicInterruptMessage* Arena::CreateMaybeMessage<::LogicInterruptMessage>(Arena*);
template<> ::LogicMessage* Arena::CreateMaybeMessage<::LogicMessage>(Arena*);
template<> ::RawCommand* Arena::CreateMaybeMessage<::RawCommand>(Arena*);
template<> ::SensorConfig* Arena::CreateMaybeMessage<::SensorConfig>(Arena*);
template<> ::SensorField* Arena::CreateMaybeMessage<::SensorField>(Arena*);
template<> ::SensorLed* Arena::CreateMaybeMessage<::SensorLed>(Arena*);
template<> ::SensorState* Arena::CreateMaybeMessage<::SensorState>(Arena*);
template<> ::SensorStatus* Arena::CreateMaybeMessage<::SensorStatus>(Arena*);
template<> ::StatusPacket* Arena::CreateMaybeMessage<::StatusPacket>(Arena*);
template<> ::SystemStatusMessage* Arena::CreateMaybeMessage<::SystemStatusMessage>(Arena*);
template<> ::WaveMessage* Arena::CreateMaybeMessage<::WaveMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum LogicMessage_EnumLogicType : int {
  LogicMessage_EnumLogicType_LOGIC_SENSOR_RESTART = 1,
  LogicMessage_EnumLogicType_LOGIC_SENSOR_COARSE_ZERO = 2,
  LogicMessage_EnumLogicType_LOGIC_SENSOR_OFF = 3,
  LogicMessage_EnumLogicType_LOGIC_SENSOR_IDLE = 4,
  LogicMessage_EnumLogicType_LOGIC_SENSOR_FINE_ZERO = 5,
  LogicMessage_EnumLogicType_LOGIC_SENSOR_STASIS_ON = 32,
  LogicMessage_EnumLogicType_LOGIC_SENSOR_STASIS_OFF = 33
};
bool LogicMessage_EnumLogicType_IsValid(int value);
constexpr LogicMessage_EnumLogicType LogicMessage_EnumLogicType_EnumLogicType_MIN = LogicMessage_EnumLogicType_LOGIC_SENSOR_RESTART;
constexpr LogicMessage_EnumLogicType LogicMessage_EnumLogicType_EnumLogicType_MAX = LogicMessage_EnumLogicType_LOGIC_SENSOR_STASIS_OFF;
constexpr int LogicMessage_EnumLogicType_EnumLogicType_ARRAYSIZE = LogicMessage_EnumLogicType_EnumLogicType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogicMessage_EnumLogicType_descriptor();
template<typename T>
inline const std::string& LogicMessage_EnumLogicType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogicMessage_EnumLogicType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogicMessage_EnumLogicType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogicMessage_EnumLogicType_descriptor(), enum_t_value);
}
inline bool LogicMessage_EnumLogicType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogicMessage_EnumLogicType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogicMessage_EnumLogicType>(
    LogicMessage_EnumLogicType_descriptor(), name, value);
}
enum WaveMessage_WaveType : int {
  WaveMessage_WaveType_WAVE_OFF = 0,
  WaveMessage_WaveType_WAVE_RAMP = 1,
  WaveMessage_WaveType_WAVE_SINE = 2
};
bool WaveMessage_WaveType_IsValid(int value);
constexpr WaveMessage_WaveType WaveMessage_WaveType_WaveType_MIN = WaveMessage_WaveType_WAVE_OFF;
constexpr WaveMessage_WaveType WaveMessage_WaveType_WaveType_MAX = WaveMessage_WaveType_WAVE_SINE;
constexpr int WaveMessage_WaveType_WaveType_ARRAYSIZE = WaveMessage_WaveType_WaveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WaveMessage_WaveType_descriptor();
template<typename T>
inline const std::string& WaveMessage_WaveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WaveMessage_WaveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WaveMessage_WaveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WaveMessage_WaveType_descriptor(), enum_t_value);
}
inline bool WaveMessage_WaveType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WaveMessage_WaveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WaveMessage_WaveType>(
    WaveMessage_WaveType_descriptor(), name, value);
}
enum CmdPacket_EnumCmdType : int {
  CmdPacket_EnumCmdType_STATUS_REQ = 2,
  CmdPacket_EnumCmdType_CONFIG_DATA = 3,
  CmdPacket_EnumCmdType_RAW_CMD = 4,
  CmdPacket_EnumCmdType_RAW_CMD_RESP = 5,
  CmdPacket_EnumCmdType_DL_URI = 6,
  CmdPacket_EnumCmdType_RESET_FPGA = 7,
  CmdPacket_EnumCmdType_UPDATE = 8,
  CmdPacket_EnumCmdType_UPDATE_COMMIT = 9,
  CmdPacket_EnumCmdType_SENSOR_STATUS_REQ = 10,
  CmdPacket_EnumCmdType_SENSOR_CONFIG_REQ = 11,
  CmdPacket_EnumCmdType_FLASH_CHASSIS = 12,
  CmdPacket_EnumCmdType_FLASH_SENSORS = 13,
  CmdPacket_EnumCmdType_REBOOT = 14,
  CmdPacket_EnumCmdType_SYNC = 15,
  CmdPacket_EnumCmdType_ONE_TIME_READ_REQ = 16,
  CmdPacket_EnumCmdType_CONFIG_LIST = 17,
  CmdPacket_EnumCmdType_DEV_MODE_REQ = 18,
  CmdPacket_EnumCmdType_LOGIC_REQ = 19,
  CmdPacket_EnumCmdType_WAVE_REQ = 20,
  CmdPacket_EnumCmdType_IDENT_REQ = 21,
  CmdPacket_EnumCmdType_CLOSED_LOOP_REQ = 22,
  CmdPacket_EnumCmdType_SYSTEM_STATUS_REQ = 23,
  CmdPacket_EnumCmdType_LOGIC_INTERRUPT_REQ = 24,
  CmdPacket_EnumCmdType_SYNC_CMD_REQ = 25,
  CmdPacket_EnumCmdType_COMPLETE_SYSTEM_STATUS_REQ = 26
};
bool CmdPacket_EnumCmdType_IsValid(int value);
constexpr CmdPacket_EnumCmdType CmdPacket_EnumCmdType_EnumCmdType_MIN = CmdPacket_EnumCmdType_STATUS_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket_EnumCmdType_EnumCmdType_MAX = CmdPacket_EnumCmdType_COMPLETE_SYSTEM_STATUS_REQ;
constexpr int CmdPacket_EnumCmdType_EnumCmdType_ARRAYSIZE = CmdPacket_EnumCmdType_EnumCmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CmdPacket_EnumCmdType_descriptor();
template<typename T>
inline const std::string& CmdPacket_EnumCmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CmdPacket_EnumCmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CmdPacket_EnumCmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CmdPacket_EnumCmdType_descriptor(), enum_t_value);
}
inline bool CmdPacket_EnumCmdType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CmdPacket_EnumCmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CmdPacket_EnumCmdType>(
    CmdPacket_EnumCmdType_descriptor(), name, value);
}
enum SensorState_EnumStateType : int {
  SensorState_EnumStateType_OFF = 0,
  SensorState_EnumStateType_IDLE = 1,
  SensorState_EnumStateType_ERROR = 2,
  SensorState_EnumStateType_SOFT_ERROR = 3,
  SensorState_EnumStateType_READY = 4,
  SensorState_EnumStateType_RESTART = 10,
  SensorState_EnumStateType_RESTART_COMPLETE = 11,
  SensorState_EnumStateType_COARSE_ZERO = 12,
  SensorState_EnumStateType_COARSE_ZERO_COMPLETE = 13,
  SensorState_EnumStateType_FINE_ZERO = 14,
  SensorState_EnumStateType_FINE_ZERO_COMPLETE = 15
};
bool SensorState_EnumStateType_IsValid(int value);
constexpr SensorState_EnumStateType SensorState_EnumStateType_EnumStateType_MIN = SensorState_EnumStateType_OFF;
constexpr SensorState_EnumStateType SensorState_EnumStateType_EnumStateType_MAX = SensorState_EnumStateType_FINE_ZERO_COMPLETE;
constexpr int SensorState_EnumStateType_EnumStateType_ARRAYSIZE = SensorState_EnumStateType_EnumStateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorState_EnumStateType_descriptor();
template<typename T>
inline const std::string& SensorState_EnumStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorState_EnumStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorState_EnumStateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorState_EnumStateType_descriptor(), enum_t_value);
}
inline bool SensorState_EnumStateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SensorState_EnumStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorState_EnumStateType>(
    SensorState_EnumStateType_descriptor(), name, value);
}
enum StatusPacket_EnumStatusType : int {
  StatusPacket_EnumStatusType_STATUS = 0,
  StatusPacket_EnumStatusType_PROGRESS = 1,
  StatusPacket_EnumStatusType_SENSOR_STATUS = 2,
  StatusPacket_EnumStatusType_SENSOR_CONFIG = 3,
  StatusPacket_EnumStatusType_SENSOR_LED = 4,
  StatusPacket_EnumStatusType_SENSOR_STATE = 5,
  StatusPacket_EnumStatusType_SENSOR_FIELD = 6,
  StatusPacket_EnumStatusType_SYSTEM_STATUS = 7,
  StatusPacket_EnumStatusType_COMPLETE_SYSTEM_STATUS = 8
};
bool StatusPacket_EnumStatusType_IsValid(int value);
constexpr StatusPacket_EnumStatusType StatusPacket_EnumStatusType_EnumStatusType_MIN = StatusPacket_EnumStatusType_STATUS;
constexpr StatusPacket_EnumStatusType StatusPacket_EnumStatusType_EnumStatusType_MAX = StatusPacket_EnumStatusType_COMPLETE_SYSTEM_STATUS;
constexpr int StatusPacket_EnumStatusType_EnumStatusType_ARRAYSIZE = StatusPacket_EnumStatusType_EnumStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusPacket_EnumStatusType_descriptor();
template<typename T>
inline const std::string& StatusPacket_EnumStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusPacket_EnumStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusPacket_EnumStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusPacket_EnumStatusType_descriptor(), enum_t_value);
}
inline bool StatusPacket_EnumStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusPacket_EnumStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusPacket_EnumStatusType>(
    StatusPacket_EnumStatusType_descriptor(), name, value);
}
enum StatusPacket_EnumSystemStatus : int {
  StatusPacket_EnumSystemStatus_STARTUP = 0,
  StatusPacket_EnumSystemStatus_FLASHING = 1,
  StatusPacket_EnumSystemStatus_RUNNING = 2,
  StatusPacket_EnumSystemStatus_MENDER_UPDATE_FAIL = 3,
  StatusPacket_EnumSystemStatus_FPGA_UPDATE_FAIL = 4,
  StatusPacket_EnumSystemStatus_PENDING_COMMIT = 5,
  StatusPacket_EnumSystemStatus_STARTUP_ERROR = 6
};
bool StatusPacket_EnumSystemStatus_IsValid(int value);
constexpr StatusPacket_EnumSystemStatus StatusPacket_EnumSystemStatus_EnumSystemStatus_MIN = StatusPacket_EnumSystemStatus_STARTUP;
constexpr StatusPacket_EnumSystemStatus StatusPacket_EnumSystemStatus_EnumSystemStatus_MAX = StatusPacket_EnumSystemStatus_STARTUP_ERROR;
constexpr int StatusPacket_EnumSystemStatus_EnumSystemStatus_ARRAYSIZE = StatusPacket_EnumSystemStatus_EnumSystemStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusPacket_EnumSystemStatus_descriptor();
template<typename T>
inline const std::string& StatusPacket_EnumSystemStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusPacket_EnumSystemStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusPacket_EnumSystemStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusPacket_EnumSystemStatus_descriptor(), enum_t_value);
}
inline bool StatusPacket_EnumSystemStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusPacket_EnumSystemStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusPacket_EnumSystemStatus>(
    StatusPacket_EnumSystemStatus_descriptor(), name, value);
}
// ===================================================================

class DataFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataFrame) */ {
 public:
  inline DataFrame() : DataFrame(nullptr) {}
  ~DataFrame() override;
  explicit constexpr DataFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataFrame(const DataFrame& from);
  DataFrame(DataFrame&& from) noexcept
    : DataFrame() {
    *this = ::std::move(from);
  }

  inline DataFrame& operator=(const DataFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataFrame& operator=(DataFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataFrame* internal_default_instance() {
    return reinterpret_cast<const DataFrame*>(
               &_DataFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DataFrame& a, DataFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(DataFrame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataFrame* New() const final {
    return new DataFrame();
  }

  DataFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataFrame& from);
  void MergeFrom(const DataFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataFrame";
  }
  protected:
  explicit DataFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorFieldNumber = 1,
    kDatatypeFieldNumber = 2,
    kValFieldNumber = 3,
  };
  // required int32 sensor = 1;
  bool has_sensor() const;
  private:
  bool _internal_has_sensor() const;
  public:
  void clear_sensor();
  ::PROTOBUF_NAMESPACE_ID::int32 sensor() const;
  void set_sensor(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sensor() const;
  void _internal_set_sensor(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 datatype = 2;
  bool has_datatype() const;
  private:
  bool _internal_has_datatype() const;
  public:
  void clear_datatype();
  ::PROTOBUF_NAMESPACE_ID::int32 datatype() const;
  void set_datatype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_datatype() const;
  void _internal_set_datatype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 val = 3;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  ::PROTOBUF_NAMESPACE_ID::int32 val() const;
  void set_val(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_val() const;
  void _internal_set_val(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:DataFrame)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 sensor_;
  ::PROTOBUF_NAMESPACE_ID::int32 datatype_;
  ::PROTOBUF_NAMESPACE_ID::int32 val_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class DataPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataPacket) */ {
 public:
  inline DataPacket() : DataPacket(nullptr) {}
  ~DataPacket() override;
  explicit constexpr DataPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataPacket(const DataPacket& from);
  DataPacket(DataPacket&& from) noexcept
    : DataPacket() {
    *this = ::std::move(from);
  }

  inline DataPacket& operator=(const DataPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPacket& operator=(DataPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataPacket* internal_default_instance() {
    return reinterpret_cast<const DataPacket*>(
               &_DataPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DataPacket& a, DataPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(DataPacket* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataPacket* New() const final {
    return new DataPacket();
  }

  DataPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataPacket& from);
  void MergeFrom(const DataPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataPacket";
  }
  protected:
  explicit DataPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kChassisNameFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kNumSensorsFieldNumber = 3,
  };
  // repeated .DataFrame data = 4;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::DataFrame* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataFrame >*
      mutable_data();
  private:
  const ::DataFrame& _internal_data(int index) const;
  ::DataFrame* _internal_add_data();
  public:
  const ::DataFrame& data(int index) const;
  ::DataFrame* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataFrame >&
      data() const;

  // required string chassis_name = 2;
  bool has_chassis_name() const;
  private:
  bool _internal_has_chassis_name() const;
  public:
  void clear_chassis_name();
  const std::string& chassis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chassis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chassis_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_chassis_name();
  void set_allocated_chassis_name(std::string* chassis_name);
  private:
  const std::string& _internal_chassis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chassis_name(const std::string& value);
  std::string* _internal_mutable_chassis_name();
  public:

  // required uint32 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required int32 num_sensors = 3;
  bool has_num_sensors() const;
  private:
  bool _internal_has_num_sensors() const;
  public:
  void clear_num_sensors();
  ::PROTOBUF_NAMESPACE_ID::int32 num_sensors() const;
  void set_num_sensors(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_sensors() const;
  void _internal_set_num_sensors(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:DataPacket)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataFrame > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chassis_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_sensors_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class RawCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RawCommand) */ {
 public:
  inline RawCommand() : RawCommand(nullptr) {}
  ~RawCommand() override;
  explicit constexpr RawCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RawCommand(const RawCommand& from);
  RawCommand(RawCommand&& from) noexcept
    : RawCommand() {
    *this = ::std::move(from);
  }

  inline RawCommand& operator=(const RawCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawCommand& operator=(RawCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RawCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const RawCommand* internal_default_instance() {
    return reinterpret_cast<const RawCommand*>(
               &_RawCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RawCommand& a, RawCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RawCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RawCommand* New() const final {
    return new RawCommand();
  }

  RawCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RawCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RawCommand& from);
  void MergeFrom(const RawCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RawCommand";
  }
  protected:
  explicit RawCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllSensorsFieldNumber = 1,
    kSensorNumFieldNumber = 2,
    kRegisterAddressFieldNumber = 3,
    kDataFieldNumber = 4,
  };
  // required bool all_sensors = 1;
  bool has_all_sensors() const;
  private:
  bool _internal_has_all_sensors() const;
  public:
  void clear_all_sensors();
  bool all_sensors() const;
  void set_all_sensors(bool value);
  private:
  bool _internal_all_sensors() const;
  void _internal_set_all_sensors(bool value);
  public:

  // required uint32 sensor_num = 2;
  bool has_sensor_num() const;
  private:
  bool _internal_has_sensor_num() const;
  public:
  void clear_sensor_num();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_num() const;
  void set_sensor_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_num() const;
  void _internal_set_sensor_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 register_address = 3;
  bool has_register_address() const;
  private:
  bool _internal_has_register_address() const;
  public:
  void clear_register_address();
  ::PROTOBUF_NAMESPACE_ID::uint32 register_address() const;
  void set_register_address(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_register_address() const;
  void _internal_set_register_address(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  ::PROTOBUF_NAMESPACE_ID::uint32 data() const;
  void set_data(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_data() const;
  void _internal_set_data(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:RawCommand)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool all_sensors_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_num_;
  ::PROTOBUF_NAMESPACE_ID::uint32 register_address_;
  ::PROTOBUF_NAMESPACE_ID::uint32 data_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class DevModeValidation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DevModeValidation) */ {
 public:
  inline DevModeValidation() : DevModeValidation(nullptr) {}
  ~DevModeValidation() override;
  explicit constexpr DevModeValidation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevModeValidation(const DevModeValidation& from);
  DevModeValidation(DevModeValidation&& from) noexcept
    : DevModeValidation() {
    *this = ::std::move(from);
  }

  inline DevModeValidation& operator=(const DevModeValidation& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevModeValidation& operator=(DevModeValidation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DevModeValidation& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevModeValidation* internal_default_instance() {
    return reinterpret_cast<const DevModeValidation*>(
               &_DevModeValidation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DevModeValidation& a, DevModeValidation& b) {
    a.Swap(&b);
  }
  inline void Swap(DevModeValidation* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevModeValidation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DevModeValidation* New() const final {
    return new DevModeValidation();
  }

  DevModeValidation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DevModeValidation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DevModeValidation& from);
  void MergeFrom(const DevModeValidation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DevModeValidation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DevModeValidation";
  }
  protected:
  explicit DevModeValidation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 1,
    kValidFieldNumber = 2,
    kEnableFieldNumber = 3,
  };
  // optional string password = 1;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional bool valid = 2;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // optional bool enable = 3;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DevModeValidation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  bool valid_;
  bool enable_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class ConfigMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConfigMessage) */ {
 public:
  inline ConfigMessage() : ConfigMessage(nullptr) {}
  ~ConfigMessage() override;
  explicit constexpr ConfigMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigMessage(const ConfigMessage& from);
  ConfigMessage(ConfigMessage&& from) noexcept
    : ConfigMessage() {
    *this = ::std::move(from);
  }

  inline ConfigMessage& operator=(const ConfigMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigMessage& operator=(ConfigMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigMessage* internal_default_instance() {
    return reinterpret_cast<const ConfigMessage*>(
               &_ConfigMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConfigMessage& a, ConfigMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfigMessage* New() const final {
    return new ConfigMessage();
  }

  ConfigMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConfigMessage& from);
  void MergeFrom(const ConfigMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConfigMessage";
  }
  protected:
  explicit ConfigMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorIdFieldNumber = 1,
    kDatatypeFieldNumber = 2,
    kFreqFieldNumber = 3,
  };
  // optional uint32 sensor_id = 1;
  bool has_sensor_id() const;
  private:
  bool _internal_has_sensor_id() const;
  public:
  void clear_sensor_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_id() const;
  void _internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 datatype = 2;
  bool has_datatype() const;
  private:
  bool _internal_has_datatype() const;
  public:
  void clear_datatype();
  ::PROTOBUF_NAMESPACE_ID::uint32 datatype() const;
  void set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_datatype() const;
  void _internal_set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 freq = 3;
  bool has_freq() const;
  private:
  bool _internal_has_freq() const;
  public:
  void clear_freq();
  ::PROTOBUF_NAMESPACE_ID::uint32 freq() const;
  void set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_freq() const;
  void _internal_set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ConfigMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 datatype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 freq_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class LogicMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LogicMessage) */ {
 public:
  inline LogicMessage() : LogicMessage(nullptr) {}
  ~LogicMessage() override;
  explicit constexpr LogicMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogicMessage(const LogicMessage& from);
  LogicMessage(LogicMessage&& from) noexcept
    : LogicMessage() {
    *this = ::std::move(from);
  }

  inline LogicMessage& operator=(const LogicMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicMessage& operator=(LogicMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogicMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicMessage* internal_default_instance() {
    return reinterpret_cast<const LogicMessage*>(
               &_LogicMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogicMessage& a, LogicMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogicMessage* New() const final {
    return new LogicMessage();
  }

  LogicMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogicMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogicMessage& from);
  void MergeFrom(const LogicMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogicMessage";
  }
  protected:
  explicit LogicMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogicMessage_EnumLogicType EnumLogicType;
  static constexpr EnumLogicType LOGIC_SENSOR_RESTART =
    LogicMessage_EnumLogicType_LOGIC_SENSOR_RESTART;
  static constexpr EnumLogicType LOGIC_SENSOR_COARSE_ZERO =
    LogicMessage_EnumLogicType_LOGIC_SENSOR_COARSE_ZERO;
  static constexpr EnumLogicType LOGIC_SENSOR_OFF =
    LogicMessage_EnumLogicType_LOGIC_SENSOR_OFF;
  static constexpr EnumLogicType LOGIC_SENSOR_IDLE =
    LogicMessage_EnumLogicType_LOGIC_SENSOR_IDLE;
  static constexpr EnumLogicType LOGIC_SENSOR_FINE_ZERO =
    LogicMessage_EnumLogicType_LOGIC_SENSOR_FINE_ZERO;
  static constexpr EnumLogicType LOGIC_SENSOR_STASIS_ON =
    LogicMessage_EnumLogicType_LOGIC_SENSOR_STASIS_ON;
  static constexpr EnumLogicType LOGIC_SENSOR_STASIS_OFF =
    LogicMessage_EnumLogicType_LOGIC_SENSOR_STASIS_OFF;
  static inline bool EnumLogicType_IsValid(int value) {
    return LogicMessage_EnumLogicType_IsValid(value);
  }
  static constexpr EnumLogicType EnumLogicType_MIN =
    LogicMessage_EnumLogicType_EnumLogicType_MIN;
  static constexpr EnumLogicType EnumLogicType_MAX =
    LogicMessage_EnumLogicType_EnumLogicType_MAX;
  static constexpr int EnumLogicType_ARRAYSIZE =
    LogicMessage_EnumLogicType_EnumLogicType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EnumLogicType_descriptor() {
    return LogicMessage_EnumLogicType_descriptor();
  }
  template<typename T>
  static inline const std::string& EnumLogicType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnumLogicType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnumLogicType_Name.");
    return LogicMessage_EnumLogicType_Name(enum_t_value);
  }
  static inline bool EnumLogicType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnumLogicType* value) {
    return LogicMessage_EnumLogicType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSensorListFieldNumber = 3,
    kSensorIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated uint32 sensor_list = 3;
  int sensor_list_size() const;
  private:
  int _internal_sensor_list_size() const;
  public:
  void clear_sensor_list();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_sensor_list() const;
  void _internal_add_sensor_list(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_sensor_list();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_list(int index) const;
  void set_sensor_list(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_sensor_list(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      sensor_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_sensor_list();

  // optional uint32 sensor_id = 1;
  bool has_sensor_id() const;
  private:
  bool _internal_has_sensor_id() const;
  public:
  void clear_sensor_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_id() const;
  void _internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .LogicMessage.EnumLogicType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::LogicMessage_EnumLogicType type() const;
  void set_type(::LogicMessage_EnumLogicType value);
  private:
  ::LogicMessage_EnumLogicType _internal_type() const;
  void _internal_set_type(::LogicMessage_EnumLogicType value);
  public:

  // @@protoc_insertion_point(class_scope:LogicMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > sensor_list_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  int type_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class LogicInterruptMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LogicInterruptMessage) */ {
 public:
  inline LogicInterruptMessage() : LogicInterruptMessage(nullptr) {}
  ~LogicInterruptMessage() override;
  explicit constexpr LogicInterruptMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogicInterruptMessage(const LogicInterruptMessage& from);
  LogicInterruptMessage(LogicInterruptMessage&& from) noexcept
    : LogicInterruptMessage() {
    *this = ::std::move(from);
  }

  inline LogicInterruptMessage& operator=(const LogicInterruptMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicInterruptMessage& operator=(LogicInterruptMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogicInterruptMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicInterruptMessage* internal_default_instance() {
    return reinterpret_cast<const LogicInterruptMessage*>(
               &_LogicInterruptMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LogicInterruptMessage& a, LogicInterruptMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicInterruptMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicInterruptMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogicInterruptMessage* New() const final {
    return new LogicInterruptMessage();
  }

  LogicInterruptMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogicInterruptMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogicInterruptMessage& from);
  void MergeFrom(const LogicInterruptMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicInterruptMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogicInterruptMessage";
  }
  protected:
  explicit LogicInterruptMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorListFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated uint32 sensor_list = 2;
  int sensor_list_size() const;
  private:
  int _internal_sensor_list_size() const;
  public:
  void clear_sensor_list();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_sensor_list() const;
  void _internal_add_sensor_list(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_sensor_list();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_list(int index) const;
  void set_sensor_list(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_sensor_list(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      sensor_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_sensor_list();

  // optional uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:LogicInterruptMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > sensor_list_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class WaveMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WaveMessage) */ {
 public:
  inline WaveMessage() : WaveMessage(nullptr) {}
  ~WaveMessage() override;
  explicit constexpr WaveMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaveMessage(const WaveMessage& from);
  WaveMessage(WaveMessage&& from) noexcept
    : WaveMessage() {
    *this = ::std::move(from);
  }

  inline WaveMessage& operator=(const WaveMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaveMessage& operator=(WaveMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaveMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaveMessage* internal_default_instance() {
    return reinterpret_cast<const WaveMessage*>(
               &_WaveMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WaveMessage& a, WaveMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WaveMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaveMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WaveMessage* New() const final {
    return new WaveMessage();
  }

  WaveMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WaveMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WaveMessage& from);
  void MergeFrom(const WaveMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaveMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WaveMessage";
  }
  protected:
  explicit WaveMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WaveMessage_WaveType WaveType;
  static constexpr WaveType WAVE_OFF =
    WaveMessage_WaveType_WAVE_OFF;
  static constexpr WaveType WAVE_RAMP =
    WaveMessage_WaveType_WAVE_RAMP;
  static constexpr WaveType WAVE_SINE =
    WaveMessage_WaveType_WAVE_SINE;
  static inline bool WaveType_IsValid(int value) {
    return WaveMessage_WaveType_IsValid(value);
  }
  static constexpr WaveType WaveType_MIN =
    WaveMessage_WaveType_WaveType_MIN;
  static constexpr WaveType WaveType_MAX =
    WaveMessage_WaveType_WaveType_MAX;
  static constexpr int WaveType_ARRAYSIZE =
    WaveMessage_WaveType_WaveType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WaveType_descriptor() {
    return WaveMessage_WaveType_descriptor();
  }
  template<typename T>
  static inline const std::string& WaveType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WaveType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WaveType_Name.");
    return WaveMessage_WaveType_Name(enum_t_value);
  }
  static inline bool WaveType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WaveType* value) {
    return WaveMessage_WaveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSensorIdFieldNumber = 1,
    kFreqFieldNumber = 2,
    kAmpFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // optional uint32 sensor_id = 1;
  bool has_sensor_id() const;
  private:
  bool _internal_has_sensor_id() const;
  public:
  void clear_sensor_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_id() const;
  void _internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float freq = 2;
  bool has_freq() const;
  private:
  bool _internal_has_freq() const;
  public:
  void clear_freq();
  float freq() const;
  void set_freq(float value);
  private:
  float _internal_freq() const;
  void _internal_set_freq(float value);
  public:

  // optional float amp = 3;
  bool has_amp() const;
  private:
  bool _internal_has_amp() const;
  public:
  void clear_amp();
  float amp() const;
  void set_amp(float value);
  private:
  float _internal_amp() const;
  void _internal_set_amp(float value);
  public:

  // optional uint32 type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:WaveMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  float freq_;
  float amp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class CmdPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CmdPacket) */ {
 public:
  inline CmdPacket() : CmdPacket(nullptr) {}
  ~CmdPacket() override;
  explicit constexpr CmdPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CmdPacket(const CmdPacket& from);
  CmdPacket(CmdPacket&& from) noexcept
    : CmdPacket() {
    *this = ::std::move(from);
  }

  inline CmdPacket& operator=(const CmdPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CmdPacket& operator=(CmdPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CmdPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CmdPacket* internal_default_instance() {
    return reinterpret_cast<const CmdPacket*>(
               &_CmdPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CmdPacket& a, CmdPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(CmdPacket* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CmdPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CmdPacket* New() const final {
    return new CmdPacket();
  }

  CmdPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CmdPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CmdPacket& from);
  void MergeFrom(const CmdPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CmdPacket";
  }
  protected:
  explicit CmdPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CmdPacket_EnumCmdType EnumCmdType;
  static constexpr EnumCmdType STATUS_REQ =
    CmdPacket_EnumCmdType_STATUS_REQ;
  static constexpr EnumCmdType CONFIG_DATA =
    CmdPacket_EnumCmdType_CONFIG_DATA;
  static constexpr EnumCmdType RAW_CMD =
    CmdPacket_EnumCmdType_RAW_CMD;
  static constexpr EnumCmdType RAW_CMD_RESP =
    CmdPacket_EnumCmdType_RAW_CMD_RESP;
  static constexpr EnumCmdType DL_URI =
    CmdPacket_EnumCmdType_DL_URI;
  static constexpr EnumCmdType RESET_FPGA =
    CmdPacket_EnumCmdType_RESET_FPGA;
  static constexpr EnumCmdType UPDATE =
    CmdPacket_EnumCmdType_UPDATE;
  static constexpr EnumCmdType UPDATE_COMMIT =
    CmdPacket_EnumCmdType_UPDATE_COMMIT;
  static constexpr EnumCmdType SENSOR_STATUS_REQ =
    CmdPacket_EnumCmdType_SENSOR_STATUS_REQ;
  static constexpr EnumCmdType SENSOR_CONFIG_REQ =
    CmdPacket_EnumCmdType_SENSOR_CONFIG_REQ;
  static constexpr EnumCmdType FLASH_CHASSIS =
    CmdPacket_EnumCmdType_FLASH_CHASSIS;
  static constexpr EnumCmdType FLASH_SENSORS =
    CmdPacket_EnumCmdType_FLASH_SENSORS;
  static constexpr EnumCmdType REBOOT =
    CmdPacket_EnumCmdType_REBOOT;
  static constexpr EnumCmdType SYNC =
    CmdPacket_EnumCmdType_SYNC;
  static constexpr EnumCmdType ONE_TIME_READ_REQ =
    CmdPacket_EnumCmdType_ONE_TIME_READ_REQ;
  static constexpr EnumCmdType CONFIG_LIST =
    CmdPacket_EnumCmdType_CONFIG_LIST;
  static constexpr EnumCmdType DEV_MODE_REQ =
    CmdPacket_EnumCmdType_DEV_MODE_REQ;
  static constexpr EnumCmdType LOGIC_REQ =
    CmdPacket_EnumCmdType_LOGIC_REQ;
  static constexpr EnumCmdType WAVE_REQ =
    CmdPacket_EnumCmdType_WAVE_REQ;
  static constexpr EnumCmdType IDENT_REQ =
    CmdPacket_EnumCmdType_IDENT_REQ;
  static constexpr EnumCmdType CLOSED_LOOP_REQ =
    CmdPacket_EnumCmdType_CLOSED_LOOP_REQ;
  static constexpr EnumCmdType SYSTEM_STATUS_REQ =
    CmdPacket_EnumCmdType_SYSTEM_STATUS_REQ;
  static constexpr EnumCmdType LOGIC_INTERRUPT_REQ =
    CmdPacket_EnumCmdType_LOGIC_INTERRUPT_REQ;
  static constexpr EnumCmdType SYNC_CMD_REQ =
    CmdPacket_EnumCmdType_SYNC_CMD_REQ;
  static constexpr EnumCmdType COMPLETE_SYSTEM_STATUS_REQ =
    CmdPacket_EnumCmdType_COMPLETE_SYSTEM_STATUS_REQ;
  static inline bool EnumCmdType_IsValid(int value) {
    return CmdPacket_EnumCmdType_IsValid(value);
  }
  static constexpr EnumCmdType EnumCmdType_MIN =
    CmdPacket_EnumCmdType_EnumCmdType_MIN;
  static constexpr EnumCmdType EnumCmdType_MAX =
    CmdPacket_EnumCmdType_EnumCmdType_MAX;
  static constexpr int EnumCmdType_ARRAYSIZE =
    CmdPacket_EnumCmdType_EnumCmdType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EnumCmdType_descriptor() {
    return CmdPacket_EnumCmdType_descriptor();
  }
  template<typename T>
  static inline const std::string& EnumCmdType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnumCmdType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnumCmdType_Name.");
    return CmdPacket_EnumCmdType_Name(enum_t_value);
  }
  static inline bool EnumCmdType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnumCmdType* value) {
    return CmdPacket_EnumCmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfigListFieldNumber = 7,
    kLogicReqFieldNumber = 9,
    kWaveReqFieldNumber = 10,
    kLogicInterruptReqFieldNumber = 13,
    kUriFieldNumber = 6,
    kRawCmdFieldNumber = 5,
    kDevModeFieldNumber = 8,
    kSensorIdFieldNumber = 2,
    kDatatypeFieldNumber = 3,
    kFreqFieldNumber = 4,
    kChassisIdentFieldNumber = 11,
    kClosedLoopFieldNumber = 12,
    kNumSyncChassisFieldNumber = 14,
    kCmdFieldNumber = 1,
  };
  // repeated .ConfigMessage config_list = 7;
  int config_list_size() const;
  private:
  int _internal_config_list_size() const;
  public:
  void clear_config_list();
  ::ConfigMessage* mutable_config_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ConfigMessage >*
      mutable_config_list();
  private:
  const ::ConfigMessage& _internal_config_list(int index) const;
  ::ConfigMessage* _internal_add_config_list();
  public:
  const ::ConfigMessage& config_list(int index) const;
  ::ConfigMessage* add_config_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ConfigMessage >&
      config_list() const;

  // repeated .LogicMessage logic_req = 9;
  int logic_req_size() const;
  private:
  int _internal_logic_req_size() const;
  public:
  void clear_logic_req();
  ::LogicMessage* mutable_logic_req(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicMessage >*
      mutable_logic_req();
  private:
  const ::LogicMessage& _internal_logic_req(int index) const;
  ::LogicMessage* _internal_add_logic_req();
  public:
  const ::LogicMessage& logic_req(int index) const;
  ::LogicMessage* add_logic_req();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicMessage >&
      logic_req() const;

  // repeated .WaveMessage wave_req = 10;
  int wave_req_size() const;
  private:
  int _internal_wave_req_size() const;
  public:
  void clear_wave_req();
  ::WaveMessage* mutable_wave_req(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WaveMessage >*
      mutable_wave_req();
  private:
  const ::WaveMessage& _internal_wave_req(int index) const;
  ::WaveMessage* _internal_add_wave_req();
  public:
  const ::WaveMessage& wave_req(int index) const;
  ::WaveMessage* add_wave_req();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WaveMessage >&
      wave_req() const;

  // repeated .LogicInterruptMessage logic_interrupt_req = 13;
  int logic_interrupt_req_size() const;
  private:
  int _internal_logic_interrupt_req_size() const;
  public:
  void clear_logic_interrupt_req();
  ::LogicInterruptMessage* mutable_logic_interrupt_req(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicInterruptMessage >*
      mutable_logic_interrupt_req();
  private:
  const ::LogicInterruptMessage& _internal_logic_interrupt_req(int index) const;
  ::LogicInterruptMessage* _internal_add_logic_interrupt_req();
  public:
  const ::LogicInterruptMessage& logic_interrupt_req(int index) const;
  ::LogicInterruptMessage* add_logic_interrupt_req();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicInterruptMessage >&
      logic_interrupt_req() const;

  // optional string uri = 6;
  bool has_uri() const;
  private:
  bool _internal_has_uri() const;
  public:
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // optional .RawCommand raw_cmd = 5;
  bool has_raw_cmd() const;
  private:
  bool _internal_has_raw_cmd() const;
  public:
  void clear_raw_cmd();
  const ::RawCommand& raw_cmd() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::RawCommand* release_raw_cmd();
  ::RawCommand* mutable_raw_cmd();
  void set_allocated_raw_cmd(::RawCommand* raw_cmd);
  private:
  const ::RawCommand& _internal_raw_cmd() const;
  ::RawCommand* _internal_mutable_raw_cmd();
  public:
  void unsafe_arena_set_allocated_raw_cmd(
      ::RawCommand* raw_cmd);
  ::RawCommand* unsafe_arena_release_raw_cmd();

  // optional .DevModeValidation dev_mode = 8;
  bool has_dev_mode() const;
  private:
  bool _internal_has_dev_mode() const;
  public:
  void clear_dev_mode();
  const ::DevModeValidation& dev_mode() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::DevModeValidation* release_dev_mode();
  ::DevModeValidation* mutable_dev_mode();
  void set_allocated_dev_mode(::DevModeValidation* dev_mode);
  private:
  const ::DevModeValidation& _internal_dev_mode() const;
  ::DevModeValidation* _internal_mutable_dev_mode();
  public:
  void unsafe_arena_set_allocated_dev_mode(
      ::DevModeValidation* dev_mode);
  ::DevModeValidation* unsafe_arena_release_dev_mode();

  // optional uint32 sensor_id = 2;
  bool has_sensor_id() const;
  private:
  bool _internal_has_sensor_id() const;
  public:
  void clear_sensor_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_id() const;
  void _internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 datatype = 3;
  bool has_datatype() const;
  private:
  bool _internal_has_datatype() const;
  public:
  void clear_datatype();
  ::PROTOBUF_NAMESPACE_ID::uint32 datatype() const;
  void set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_datatype() const;
  void _internal_set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 freq = 4;
  bool has_freq() const;
  private:
  bool _internal_has_freq() const;
  public:
  void clear_freq();
  ::PROTOBUF_NAMESPACE_ID::uint32 freq() const;
  void set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_freq() const;
  void _internal_set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool chassis_ident = 11;
  bool has_chassis_ident() const;
  private:
  bool _internal_has_chassis_ident() const;
  public:
  void clear_chassis_ident();
  bool chassis_ident() const;
  void set_chassis_ident(bool value);
  private:
  bool _internal_chassis_ident() const;
  void _internal_set_chassis_ident(bool value);
  public:

  // optional bool closed_loop = 12;
  bool has_closed_loop() const;
  private:
  bool _internal_has_closed_loop() const;
  public:
  void clear_closed_loop();
  bool closed_loop() const;
  void set_closed_loop(bool value);
  private:
  bool _internal_closed_loop() const;
  void _internal_set_closed_loop(bool value);
  public:

  // optional uint32 num_sync_chassis = 14;
  bool has_num_sync_chassis() const;
  private:
  bool _internal_has_num_sync_chassis() const;
  public:
  void clear_num_sync_chassis();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_sync_chassis() const;
  void set_num_sync_chassis(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_sync_chassis() const;
  void _internal_set_num_sync_chassis(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .CmdPacket.EnumCmdType cmd = 1;
  bool has_cmd() const;
  private:
  bool _internal_has_cmd() const;
  public:
  void clear_cmd();
  ::CmdPacket_EnumCmdType cmd() const;
  void set_cmd(::CmdPacket_EnumCmdType value);
  private:
  ::CmdPacket_EnumCmdType _internal_cmd() const;
  void _internal_set_cmd(::CmdPacket_EnumCmdType value);
  public:

  // @@protoc_insertion_point(class_scope:CmdPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ConfigMessage > config_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicMessage > logic_req_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WaveMessage > wave_req_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicInterruptMessage > logic_interrupt_req_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::RawCommand* raw_cmd_;
  ::DevModeValidation* dev_mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 datatype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 freq_;
  bool chassis_ident_;
  bool closed_loop_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_sync_chassis_;
  int cmd_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class SensorStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorStatus) */ {
 public:
  inline SensorStatus() : SensorStatus(nullptr) {}
  ~SensorStatus() override;
  explicit constexpr SensorStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorStatus(const SensorStatus& from);
  SensorStatus(SensorStatus&& from) noexcept
    : SensorStatus() {
    *this = ::std::move(from);
  }

  inline SensorStatus& operator=(const SensorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorStatus& operator=(SensorStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorStatus* internal_default_instance() {
    return reinterpret_cast<const SensorStatus*>(
               &_SensorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SensorStatus& a, SensorStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorStatus* New() const final {
    return new SensorStatus();
  }

  SensorStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorStatus& from);
  void MergeFrom(const SensorStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorStatus";
  }
  protected:
  explicit SensorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorCardSerialNumFieldNumber = 2,
    kSensorVersionFieldNumber = 3,
    kSensorSerialNumFieldNumber = 5,
    kSensorIdFieldNumber = 1,
    kSensorConnectedFieldNumber = 4,
  };
  // optional string sensor_card_serial_num = 2;
  bool has_sensor_card_serial_num() const;
  private:
  bool _internal_has_sensor_card_serial_num() const;
  public:
  void clear_sensor_card_serial_num();
  const std::string& sensor_card_serial_num() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor_card_serial_num(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor_card_serial_num();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_sensor_card_serial_num();
  void set_allocated_sensor_card_serial_num(std::string* sensor_card_serial_num);
  private:
  const std::string& _internal_sensor_card_serial_num() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_card_serial_num(const std::string& value);
  std::string* _internal_mutable_sensor_card_serial_num();
  public:

  // optional string sensor_version = 3;
  bool has_sensor_version() const;
  private:
  bool _internal_has_sensor_version() const;
  public:
  void clear_sensor_version();
  const std::string& sensor_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor_version();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_sensor_version();
  void set_allocated_sensor_version(std::string* sensor_version);
  private:
  const std::string& _internal_sensor_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_version(const std::string& value);
  std::string* _internal_mutable_sensor_version();
  public:

  // optional string sensor_serial_num = 5;
  bool has_sensor_serial_num() const;
  private:
  bool _internal_has_sensor_serial_num() const;
  public:
  void clear_sensor_serial_num();
  const std::string& sensor_serial_num() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor_serial_num(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor_serial_num();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_sensor_serial_num();
  void set_allocated_sensor_serial_num(std::string* sensor_serial_num);
  private:
  const std::string& _internal_sensor_serial_num() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_serial_num(const std::string& value);
  std::string* _internal_mutable_sensor_serial_num();
  public:

  // required uint32 sensor_id = 1;
  bool has_sensor_id() const;
  private:
  bool _internal_has_sensor_id() const;
  public:
  void clear_sensor_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_id() const;
  void _internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool sensor_connected = 4;
  bool has_sensor_connected() const;
  private:
  bool _internal_has_sensor_connected() const;
  public:
  void clear_sensor_connected();
  bool sensor_connected() const;
  void set_sensor_connected(bool value);
  private:
  bool _internal_sensor_connected() const;
  void _internal_set_sensor_connected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SensorStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_card_serial_num_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_serial_num_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  bool sensor_connected_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class SensorState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorState) */ {
 public:
  inline SensorState() : SensorState(nullptr) {}
  ~SensorState() override;
  explicit constexpr SensorState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorState(const SensorState& from);
  SensorState(SensorState&& from) noexcept
    : SensorState() {
    *this = ::std::move(from);
  }

  inline SensorState& operator=(const SensorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorState& operator=(SensorState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorState& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorState* internal_default_instance() {
    return reinterpret_cast<const SensorState*>(
               &_SensorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SensorState& a, SensorState& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorState* New() const final {
    return new SensorState();
  }

  SensorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorState& from);
  void MergeFrom(const SensorState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorState";
  }
  protected:
  explicit SensorState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SensorState_EnumStateType EnumStateType;
  static constexpr EnumStateType OFF =
    SensorState_EnumStateType_OFF;
  static constexpr EnumStateType IDLE =
    SensorState_EnumStateType_IDLE;
  static constexpr EnumStateType ERROR =
    SensorState_EnumStateType_ERROR;
  static constexpr EnumStateType SOFT_ERROR =
    SensorState_EnumStateType_SOFT_ERROR;
  static constexpr EnumStateType READY =
    SensorState_EnumStateType_READY;
  static constexpr EnumStateType RESTART =
    SensorState_EnumStateType_RESTART;
  static constexpr EnumStateType RESTART_COMPLETE =
    SensorState_EnumStateType_RESTART_COMPLETE;
  static constexpr EnumStateType COARSE_ZERO =
    SensorState_EnumStateType_COARSE_ZERO;
  static constexpr EnumStateType COARSE_ZERO_COMPLETE =
    SensorState_EnumStateType_COARSE_ZERO_COMPLETE;
  static constexpr EnumStateType FINE_ZERO =
    SensorState_EnumStateType_FINE_ZERO;
  static constexpr EnumStateType FINE_ZERO_COMPLETE =
    SensorState_EnumStateType_FINE_ZERO_COMPLETE;
  static inline bool EnumStateType_IsValid(int value) {
    return SensorState_EnumStateType_IsValid(value);
  }
  static constexpr EnumStateType EnumStateType_MIN =
    SensorState_EnumStateType_EnumStateType_MIN;
  static constexpr EnumStateType EnumStateType_MAX =
    SensorState_EnumStateType_EnumStateType_MAX;
  static constexpr int EnumStateType_ARRAYSIZE =
    SensorState_EnumStateType_EnumStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EnumStateType_descriptor() {
    return SensorState_EnumStateType_descriptor();
  }
  template<typename T>
  static inline const std::string& EnumStateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnumStateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnumStateType_Name.");
    return SensorState_EnumStateType_Name(enum_t_value);
  }
  static inline bool EnumStateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnumStateType* value) {
    return SensorState_EnumStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSensorIdFieldNumber = 1,
    kStateFieldNumber = 2,
    kErrorFlagsFieldNumber = 3,
  };
  // optional uint32 sensor_id = 1;
  bool has_sensor_id() const;
  private:
  bool _internal_has_sensor_id() const;
  public:
  void clear_sensor_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_id() const;
  void _internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .SensorState.EnumStateType state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::SensorState_EnumStateType state() const;
  void set_state(::SensorState_EnumStateType value);
  private:
  ::SensorState_EnumStateType _internal_state() const;
  void _internal_set_state(::SensorState_EnumStateType value);
  public:

  // optional uint32 error_flags = 3;
  bool has_error_flags() const;
  private:
  bool _internal_has_error_flags() const;
  public:
  void clear_error_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 error_flags() const;
  void set_error_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_error_flags() const;
  void _internal_set_error_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SensorState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  int state_;
  ::PROTOBUF_NAMESPACE_ID::uint32 error_flags_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class SensorConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorConfig) */ {
 public:
  inline SensorConfig() : SensorConfig(nullptr) {}
  ~SensorConfig() override;
  explicit constexpr SensorConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorConfig(const SensorConfig& from);
  SensorConfig(SensorConfig&& from) noexcept
    : SensorConfig() {
    *this = ::std::move(from);
  }

  inline SensorConfig& operator=(const SensorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorConfig& operator=(SensorConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorConfig* internal_default_instance() {
    return reinterpret_cast<const SensorConfig*>(
               &_SensorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SensorConfig& a, SensorConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorConfig* New() const final {
    return new SensorConfig();
  }

  SensorConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorConfig& from);
  void MergeFrom(const SensorConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorConfig";
  }
  protected:
  explicit SensorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorFieldNumber = 1,
    kDatatypeFieldNumber = 2,
    kFreqFieldNumber = 3,
    kCalibrationFieldNumber = 4,
  };
  // required uint32 sensor = 1;
  bool has_sensor() const;
  private:
  bool _internal_has_sensor() const;
  public:
  void clear_sensor();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor() const;
  void set_sensor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor() const;
  void _internal_set_sensor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 datatype = 2;
  bool has_datatype() const;
  private:
  bool _internal_has_datatype() const;
  public:
  void clear_datatype();
  ::PROTOBUF_NAMESPACE_ID::uint32 datatype() const;
  void set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_datatype() const;
  void _internal_set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 freq = 3;
  bool has_freq() const;
  private:
  bool _internal_has_freq() const;
  public:
  void clear_freq();
  ::PROTOBUF_NAMESPACE_ID::uint32 freq() const;
  void set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_freq() const;
  void _internal_set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float calibration = 4;
  bool has_calibration() const;
  private:
  bool _internal_has_calibration() const;
  public:
  void clear_calibration();
  float calibration() const;
  void set_calibration(float value);
  private:
  float _internal_calibration() const;
  void _internal_set_calibration(float value);
  public:

  // @@protoc_insertion_point(class_scope:SensorConfig)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_;
  ::PROTOBUF_NAMESPACE_ID::uint32 datatype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 freq_;
  float calibration_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class SensorLed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorLed) */ {
 public:
  inline SensorLed() : SensorLed(nullptr) {}
  ~SensorLed() override;
  explicit constexpr SensorLed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorLed(const SensorLed& from);
  SensorLed(SensorLed&& from) noexcept
    : SensorLed() {
    *this = ::std::move(from);
  }

  inline SensorLed& operator=(const SensorLed& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorLed& operator=(SensorLed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorLed& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorLed* internal_default_instance() {
    return reinterpret_cast<const SensorLed*>(
               &_SensorLed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SensorLed& a, SensorLed& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorLed* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorLed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorLed* New() const final {
    return new SensorLed();
  }

  SensorLed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorLed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorLed& from);
  void MergeFrom(const SensorLed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorLed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorLed";
  }
  protected:
  explicit SensorLed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorIdFieldNumber = 1,
    kBlinkStateFieldNumber = 2,
    kColorFieldNumber = 3,
  };
  // optional uint32 sensor_id = 1;
  bool has_sensor_id() const;
  private:
  bool _internal_has_sensor_id() const;
  public:
  void clear_sensor_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_id() const;
  void _internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 blink_state = 2;
  bool has_blink_state() const;
  private:
  bool _internal_has_blink_state() const;
  public:
  void clear_blink_state();
  ::PROTOBUF_NAMESPACE_ID::uint32 blink_state() const;
  void set_blink_state(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_blink_state() const;
  void _internal_set_blink_state(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 color = 3;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  ::PROTOBUF_NAMESPACE_ID::uint32 color() const;
  void set_color(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_color() const;
  void _internal_set_color(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SensorLed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 blink_state_;
  ::PROTOBUF_NAMESPACE_ID::uint32 color_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class SensorField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorField) */ {
 public:
  inline SensorField() : SensorField(nullptr) {}
  ~SensorField() override;
  explicit constexpr SensorField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorField(const SensorField& from);
  SensorField(SensorField&& from) noexcept
    : SensorField() {
    *this = ::std::move(from);
  }

  inline SensorField& operator=(const SensorField& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorField& operator=(SensorField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorField& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorField* internal_default_instance() {
    return reinterpret_cast<const SensorField*>(
               &_SensorField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SensorField& a, SensorField& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorField* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorField* New() const final {
    return new SensorField();
  }

  SensorField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorField>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorField& from);
  void MergeFrom(const SensorField& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorField* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorField";
  }
  protected:
  explicit SensorField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorIdFieldNumber = 1,
    kFieldXFieldNumber = 2,
    kFieldYFieldNumber = 3,
    kFieldZFieldNumber = 4,
  };
  // optional uint32 sensor_id = 1;
  bool has_sensor_id() const;
  private:
  bool _internal_has_sensor_id() const;
  public:
  void clear_sensor_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id() const;
  void set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_id() const;
  void _internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float field_x = 2;
  bool has_field_x() const;
  private:
  bool _internal_has_field_x() const;
  public:
  void clear_field_x();
  float field_x() const;
  void set_field_x(float value);
  private:
  float _internal_field_x() const;
  void _internal_set_field_x(float value);
  public:

  // optional float field_y = 3;
  bool has_field_y() const;
  private:
  bool _internal_has_field_y() const;
  public:
  void clear_field_y();
  float field_y() const;
  void set_field_y(float value);
  private:
  float _internal_field_y() const;
  void _internal_set_field_y(float value);
  public:

  // optional float field_z = 4;
  bool has_field_z() const;
  private:
  bool _internal_has_field_z() const;
  public:
  void clear_field_z();
  float field_z() const;
  void set_field_z(float value);
  private:
  float _internal_field_z() const;
  void _internal_set_field_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:SensorField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_id_;
  float field_x_;
  float field_y_;
  float field_z_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class ChassisStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChassisStatus) */ {
 public:
  inline ChassisStatus() : ChassisStatus(nullptr) {}
  ~ChassisStatus() override;
  explicit constexpr ChassisStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChassisStatus(const ChassisStatus& from);
  ChassisStatus(ChassisStatus&& from) noexcept
    : ChassisStatus() {
    *this = ::std::move(from);
  }

  inline ChassisStatus& operator=(const ChassisStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChassisStatus& operator=(ChassisStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChassisStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChassisStatus* internal_default_instance() {
    return reinterpret_cast<const ChassisStatus*>(
               &_ChassisStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ChassisStatus& a, ChassisStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ChassisStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChassisStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChassisStatus* New() const final {
    return new ChassisStatus();
  }

  ChassisStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChassisStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChassisStatus& from);
  void MergeFrom(const ChassisStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChassisStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChassisStatus";
  }
  protected:
  explicit ChassisStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClosedLoopFieldNumber = 1,
  };
  // optional bool closed_loop = 1;
  bool has_closed_loop() const;
  private:
  bool _internal_has_closed_loop() const;
  public:
  void clear_closed_loop();
  bool closed_loop() const;
  void set_closed_loop(bool value);
  private:
  bool _internal_closed_loop() const;
  void _internal_set_closed_loop(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ChassisStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool closed_loop_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class SystemStatusMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemStatusMessage) */ {
 public:
  inline SystemStatusMessage() : SystemStatusMessage(nullptr) {}
  ~SystemStatusMessage() override;
  explicit constexpr SystemStatusMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemStatusMessage(const SystemStatusMessage& from);
  SystemStatusMessage(SystemStatusMessage&& from) noexcept
    : SystemStatusMessage() {
    *this = ::std::move(from);
  }

  inline SystemStatusMessage& operator=(const SystemStatusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemStatusMessage& operator=(SystemStatusMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemStatusMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemStatusMessage* internal_default_instance() {
    return reinterpret_cast<const SystemStatusMessage*>(
               &_SystemStatusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SystemStatusMessage& a, SystemStatusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemStatusMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemStatusMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemStatusMessage* New() const final {
    return new SystemStatusMessage();
  }

  SystemStatusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemStatusMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SystemStatusMessage& from);
  void MergeFrom(const SystemStatusMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemStatusMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemStatusMessage";
  }
  protected:
  explicit SystemStatusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 3,
    kMasterFieldNumber = 4,
    kSerialFieldNumber = 5,
    kSerialShortFieldNumber = 6,
    kNumFieldNumber = 1,
    kTotalFieldNumber = 2,
  };
  // optional string version = 3;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string master = 4;
  bool has_master() const;
  private:
  bool _internal_has_master() const;
  public:
  void clear_master();
  const std::string& master() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_master(ArgT0&& arg0, ArgT... args);
  std::string* mutable_master();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_master();
  void set_allocated_master(std::string* master);
  private:
  const std::string& _internal_master() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_master(const std::string& value);
  std::string* _internal_mutable_master();
  public:

  // optional string serial = 5;
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // optional string serial_short = 6;
  bool has_serial_short() const;
  private:
  bool _internal_has_serial_short() const;
  public:
  void clear_serial_short();
  const std::string& serial_short() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_short(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_short();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_serial_short();
  void set_allocated_serial_short(std::string* serial_short);
  private:
  const std::string& _internal_serial_short() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_short(const std::string& value);
  std::string* _internal_mutable_serial_short();
  public:

  // optional uint32 num = 1;
  bool has_num() const;
  private:
  bool _internal_has_num() const;
  public:
  void clear_num();
  ::PROTOBUF_NAMESPACE_ID::uint32 num() const;
  void set_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num() const;
  void _internal_set_num(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 total = 2;
  bool has_total() const;
  private:
  bool _internal_has_total() const;
  public:
  void clear_total();
  ::PROTOBUF_NAMESPACE_ID::uint32 total() const;
  void set_total(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_total() const;
  void _internal_set_total(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SystemStatusMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr master_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_short_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// -------------------------------------------------------------------

class StatusPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatusPacket) */ {
 public:
  inline StatusPacket() : StatusPacket(nullptr) {}
  ~StatusPacket() override;
  explicit constexpr StatusPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusPacket(const StatusPacket& from);
  StatusPacket(StatusPacket&& from) noexcept
    : StatusPacket() {
    *this = ::std::move(from);
  }

  inline StatusPacket& operator=(const StatusPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusPacket& operator=(StatusPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusPacket* internal_default_instance() {
    return reinterpret_cast<const StatusPacket*>(
               &_StatusPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StatusPacket& a, StatusPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusPacket* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusPacket* New() const final {
    return new StatusPacket();
  }

  StatusPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusPacket& from);
  void MergeFrom(const StatusPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatusPacket";
  }
  protected:
  explicit StatusPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StatusPacket_EnumStatusType EnumStatusType;
  static constexpr EnumStatusType STATUS =
    StatusPacket_EnumStatusType_STATUS;
  static constexpr EnumStatusType PROGRESS =
    StatusPacket_EnumStatusType_PROGRESS;
  static constexpr EnumStatusType SENSOR_STATUS =
    StatusPacket_EnumStatusType_SENSOR_STATUS;
  static constexpr EnumStatusType SENSOR_CONFIG =
    StatusPacket_EnumStatusType_SENSOR_CONFIG;
  static constexpr EnumStatusType SENSOR_LED =
    StatusPacket_EnumStatusType_SENSOR_LED;
  static constexpr EnumStatusType SENSOR_STATE =
    StatusPacket_EnumStatusType_SENSOR_STATE;
  static constexpr EnumStatusType SENSOR_FIELD =
    StatusPacket_EnumStatusType_SENSOR_FIELD;
  static constexpr EnumStatusType SYSTEM_STATUS =
    StatusPacket_EnumStatusType_SYSTEM_STATUS;
  static constexpr EnumStatusType COMPLETE_SYSTEM_STATUS =
    StatusPacket_EnumStatusType_COMPLETE_SYSTEM_STATUS;
  static inline bool EnumStatusType_IsValid(int value) {
    return StatusPacket_EnumStatusType_IsValid(value);
  }
  static constexpr EnumStatusType EnumStatusType_MIN =
    StatusPacket_EnumStatusType_EnumStatusType_MIN;
  static constexpr EnumStatusType EnumStatusType_MAX =
    StatusPacket_EnumStatusType_EnumStatusType_MAX;
  static constexpr int EnumStatusType_ARRAYSIZE =
    StatusPacket_EnumStatusType_EnumStatusType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EnumStatusType_descriptor() {
    return StatusPacket_EnumStatusType_descriptor();
  }
  template<typename T>
  static inline const std::string& EnumStatusType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnumStatusType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnumStatusType_Name.");
    return StatusPacket_EnumStatusType_Name(enum_t_value);
  }
  static inline bool EnumStatusType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnumStatusType* value) {
    return StatusPacket_EnumStatusType_Parse(name, value);
  }

  typedef StatusPacket_EnumSystemStatus EnumSystemStatus;
  static constexpr EnumSystemStatus STARTUP =
    StatusPacket_EnumSystemStatus_STARTUP;
  static constexpr EnumSystemStatus FLASHING =
    StatusPacket_EnumSystemStatus_FLASHING;
  static constexpr EnumSystemStatus RUNNING =
    StatusPacket_EnumSystemStatus_RUNNING;
  static constexpr EnumSystemStatus MENDER_UPDATE_FAIL =
    StatusPacket_EnumSystemStatus_MENDER_UPDATE_FAIL;
  static constexpr EnumSystemStatus FPGA_UPDATE_FAIL =
    StatusPacket_EnumSystemStatus_FPGA_UPDATE_FAIL;
  static constexpr EnumSystemStatus PENDING_COMMIT =
    StatusPacket_EnumSystemStatus_PENDING_COMMIT;
  static constexpr EnumSystemStatus STARTUP_ERROR =
    StatusPacket_EnumSystemStatus_STARTUP_ERROR;
  static inline bool EnumSystemStatus_IsValid(int value) {
    return StatusPacket_EnumSystemStatus_IsValid(value);
  }
  static constexpr EnumSystemStatus EnumSystemStatus_MIN =
    StatusPacket_EnumSystemStatus_EnumSystemStatus_MIN;
  static constexpr EnumSystemStatus EnumSystemStatus_MAX =
    StatusPacket_EnumSystemStatus_EnumSystemStatus_MAX;
  static constexpr int EnumSystemStatus_ARRAYSIZE =
    StatusPacket_EnumSystemStatus_EnumSystemStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EnumSystemStatus_descriptor() {
    return StatusPacket_EnumSystemStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& EnumSystemStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnumSystemStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnumSystemStatus_Name.");
    return StatusPacket_EnumSystemStatus_Name(enum_t_value);
  }
  static inline bool EnumSystemStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnumSystemStatus* value) {
    return StatusPacket_EnumSystemStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSensorStatusFieldNumber = 4,
    kSensorConfigFieldNumber = 8,
    kSensorLedFieldNumber = 10,
    kSensorStateFieldNumber = 11,
    kSensorFieldFieldNumber = 12,
    kChassisNameFieldNumber = 1,
    kVersionFieldNumber = 5,
    kProgressMsgFieldNumber = 7,
    kChassisStatusFieldNumber = 13,
    kSystemStatusFieldNumber = 14,
    kTypeFieldNumber = 2,
    kNumSensorsFieldNumber = 3,
    kProgressFieldNumber = 6,
    kStatusFieldNumber = 9,
  };
  // repeated .SensorStatus sensor_status = 4;
  int sensor_status_size() const;
  private:
  int _internal_sensor_status_size() const;
  public:
  void clear_sensor_status();
  ::SensorStatus* mutable_sensor_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorStatus >*
      mutable_sensor_status();
  private:
  const ::SensorStatus& _internal_sensor_status(int index) const;
  ::SensorStatus* _internal_add_sensor_status();
  public:
  const ::SensorStatus& sensor_status(int index) const;
  ::SensorStatus* add_sensor_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorStatus >&
      sensor_status() const;

  // repeated .SensorConfig sensor_config = 8;
  int sensor_config_size() const;
  private:
  int _internal_sensor_config_size() const;
  public:
  void clear_sensor_config();
  ::SensorConfig* mutable_sensor_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorConfig >*
      mutable_sensor_config();
  private:
  const ::SensorConfig& _internal_sensor_config(int index) const;
  ::SensorConfig* _internal_add_sensor_config();
  public:
  const ::SensorConfig& sensor_config(int index) const;
  ::SensorConfig* add_sensor_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorConfig >&
      sensor_config() const;

  // repeated .SensorLed sensor_led = 10;
  int sensor_led_size() const;
  private:
  int _internal_sensor_led_size() const;
  public:
  void clear_sensor_led();
  ::SensorLed* mutable_sensor_led(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorLed >*
      mutable_sensor_led();
  private:
  const ::SensorLed& _internal_sensor_led(int index) const;
  ::SensorLed* _internal_add_sensor_led();
  public:
  const ::SensorLed& sensor_led(int index) const;
  ::SensorLed* add_sensor_led();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorLed >&
      sensor_led() const;

  // repeated .SensorState sensor_state = 11;
  int sensor_state_size() const;
  private:
  int _internal_sensor_state_size() const;
  public:
  void clear_sensor_state();
  ::SensorState* mutable_sensor_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorState >*
      mutable_sensor_state();
  private:
  const ::SensorState& _internal_sensor_state(int index) const;
  ::SensorState* _internal_add_sensor_state();
  public:
  const ::SensorState& sensor_state(int index) const;
  ::SensorState* add_sensor_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorState >&
      sensor_state() const;

  // repeated .SensorField sensor_field = 12;
  int sensor_field_size() const;
  private:
  int _internal_sensor_field_size() const;
  public:
  void clear_sensor_field();
  ::SensorField* mutable_sensor_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorField >*
      mutable_sensor_field();
  private:
  const ::SensorField& _internal_sensor_field(int index) const;
  ::SensorField* _internal_add_sensor_field();
  public:
  const ::SensorField& sensor_field(int index) const;
  ::SensorField* add_sensor_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorField >&
      sensor_field() const;

  // required string chassis_name = 1;
  bool has_chassis_name() const;
  private:
  bool _internal_has_chassis_name() const;
  public:
  void clear_chassis_name();
  const std::string& chassis_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chassis_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chassis_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_chassis_name();
  void set_allocated_chassis_name(std::string* chassis_name);
  private:
  const std::string& _internal_chassis_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chassis_name(const std::string& value);
  std::string* _internal_mutable_chassis_name();
  public:

  // required string version = 5;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string progress_msg = 7;
  bool has_progress_msg() const;
  private:
  bool _internal_has_progress_msg() const;
  public:
  void clear_progress_msg();
  const std::string& progress_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_progress_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_progress_msg();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_progress_msg();
  void set_allocated_progress_msg(std::string* progress_msg);
  private:
  const std::string& _internal_progress_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_progress_msg(const std::string& value);
  std::string* _internal_mutable_progress_msg();
  public:

  // optional .ChassisStatus chassis_status = 13;
  bool has_chassis_status() const;
  private:
  bool _internal_has_chassis_status() const;
  public:
  void clear_chassis_status();
  const ::ChassisStatus& chassis_status() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::ChassisStatus* release_chassis_status();
  ::ChassisStatus* mutable_chassis_status();
  void set_allocated_chassis_status(::ChassisStatus* chassis_status);
  private:
  const ::ChassisStatus& _internal_chassis_status() const;
  ::ChassisStatus* _internal_mutable_chassis_status();
  public:
  void unsafe_arena_set_allocated_chassis_status(
      ::ChassisStatus* chassis_status);
  ::ChassisStatus* unsafe_arena_release_chassis_status();

  // optional .SystemStatusMessage system_status = 14;
  bool has_system_status() const;
  private:
  bool _internal_has_system_status() const;
  public:
  void clear_system_status();
  const ::SystemStatusMessage& system_status() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::SystemStatusMessage* release_system_status();
  ::SystemStatusMessage* mutable_system_status();
  void set_allocated_system_status(::SystemStatusMessage* system_status);
  private:
  const ::SystemStatusMessage& _internal_system_status() const;
  ::SystemStatusMessage* _internal_mutable_system_status();
  public:
  void unsafe_arena_set_allocated_system_status(
      ::SystemStatusMessage* system_status);
  ::SystemStatusMessage* unsafe_arena_release_system_status();

  // required .StatusPacket.EnumStatusType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::StatusPacket_EnumStatusType type() const;
  void set_type(::StatusPacket_EnumStatusType value);
  private:
  ::StatusPacket_EnumStatusType _internal_type() const;
  void _internal_set_type(::StatusPacket_EnumStatusType value);
  public:

  // required uint32 num_sensors = 3;
  bool has_num_sensors() const;
  private:
  bool _internal_has_num_sensors() const;
  public:
  void clear_num_sensors();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_sensors() const;
  void set_num_sensors(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_sensors() const;
  void _internal_set_num_sensors(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 progress = 6;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  ::PROTOBUF_NAMESPACE_ID::uint32 progress() const;
  void set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_progress() const;
  void _internal_set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .StatusPacket.EnumSystemStatus status = 9;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::StatusPacket_EnumSystemStatus status() const;
  void set_status(::StatusPacket_EnumSystemStatus value);
  private:
  ::StatusPacket_EnumSystemStatus _internal_status() const;
  void _internal_set_status(::StatusPacket_EnumSystemStatus value);
  public:

  // @@protoc_insertion_point(class_scope:StatusPacket)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorStatus > sensor_status_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorConfig > sensor_config_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorLed > sensor_led_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorState > sensor_state_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorField > sensor_field_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chassis_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr progress_msg_;
  ::ChassisStatus* chassis_status_;
  ::SystemStatusMessage* system_status_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_sensors_;
  ::PROTOBUF_NAMESPACE_ID::uint32 progress_;
  int status_;
  friend struct ::TableStruct_net_2dprotocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DataFrame

// required int32 sensor = 1;
inline bool DataFrame::_internal_has_sensor() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataFrame::has_sensor() const {
  return _internal_has_sensor();
}
inline void DataFrame::clear_sensor() {
  sensor_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataFrame::_internal_sensor() const {
  return sensor_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataFrame::sensor() const {
  // @@protoc_insertion_point(field_get:DataFrame.sensor)
  return _internal_sensor();
}
inline void DataFrame::_internal_set_sensor(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  sensor_ = value;
}
inline void DataFrame::set_sensor(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sensor(value);
  // @@protoc_insertion_point(field_set:DataFrame.sensor)
}

// required int32 datatype = 2;
inline bool DataFrame::_internal_has_datatype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataFrame::has_datatype() const {
  return _internal_has_datatype();
}
inline void DataFrame::clear_datatype() {
  datatype_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataFrame::_internal_datatype() const {
  return datatype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataFrame::datatype() const {
  // @@protoc_insertion_point(field_get:DataFrame.datatype)
  return _internal_datatype();
}
inline void DataFrame::_internal_set_datatype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  datatype_ = value;
}
inline void DataFrame::set_datatype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:DataFrame.datatype)
}

// required int32 val = 3;
inline bool DataFrame::_internal_has_val() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataFrame::has_val() const {
  return _internal_has_val();
}
inline void DataFrame::clear_val() {
  val_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataFrame::_internal_val() const {
  return val_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataFrame::val() const {
  // @@protoc_insertion_point(field_get:DataFrame.val)
  return _internal_val();
}
inline void DataFrame::_internal_set_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  val_ = value;
}
inline void DataFrame::set_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:DataFrame.val)
}

// -------------------------------------------------------------------

// DataPacket

// required uint32 timestamp = 1;
inline bool DataPacket::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataPacket::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void DataPacket::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPacket::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:DataPacket.timestamp)
  return _internal_timestamp();
}
inline void DataPacket::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  timestamp_ = value;
}
inline void DataPacket::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:DataPacket.timestamp)
}

// required string chassis_name = 2;
inline bool DataPacket::_internal_has_chassis_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataPacket::has_chassis_name() const {
  return _internal_has_chassis_name();
}
inline void DataPacket::clear_chassis_name() {
  chassis_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataPacket::chassis_name() const {
  // @@protoc_insertion_point(field_get:DataPacket.chassis_name)
  return _internal_chassis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataPacket::set_chassis_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 chassis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DataPacket.chassis_name)
}
inline std::string* DataPacket::mutable_chassis_name() {
  // @@protoc_insertion_point(field_mutable:DataPacket.chassis_name)
  return _internal_mutable_chassis_name();
}
inline const std::string& DataPacket::_internal_chassis_name() const {
  return chassis_name_.Get();
}
inline void DataPacket::_internal_set_chassis_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chassis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataPacket::_internal_mutable_chassis_name() {
  _has_bits_[0] |= 0x00000001u;
  return chassis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataPacket::release_chassis_name() {
  // @@protoc_insertion_point(field_release:DataPacket.chassis_name)
  if (!_internal_has_chassis_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return chassis_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataPacket::set_allocated_chassis_name(std::string* chassis_name) {
  if (chassis_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chassis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chassis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DataPacket.chassis_name)
}

// required int32 num_sensors = 3;
inline bool DataPacket::_internal_has_num_sensors() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataPacket::has_num_sensors() const {
  return _internal_has_num_sensors();
}
inline void DataPacket::clear_num_sensors() {
  num_sensors_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataPacket::_internal_num_sensors() const {
  return num_sensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataPacket::num_sensors() const {
  // @@protoc_insertion_point(field_get:DataPacket.num_sensors)
  return _internal_num_sensors();
}
inline void DataPacket::_internal_set_num_sensors(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_sensors_ = value;
}
inline void DataPacket::set_num_sensors(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_sensors(value);
  // @@protoc_insertion_point(field_set:DataPacket.num_sensors)
}

// repeated .DataFrame data = 4;
inline int DataPacket::_internal_data_size() const {
  return data_.size();
}
inline int DataPacket::data_size() const {
  return _internal_data_size();
}
inline void DataPacket::clear_data() {
  data_.Clear();
}
inline ::DataFrame* DataPacket::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:DataPacket.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataFrame >*
DataPacket::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:DataPacket.data)
  return &data_;
}
inline const ::DataFrame& DataPacket::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::DataFrame& DataPacket::data(int index) const {
  // @@protoc_insertion_point(field_get:DataPacket.data)
  return _internal_data(index);
}
inline ::DataFrame* DataPacket::_internal_add_data() {
  return data_.Add();
}
inline ::DataFrame* DataPacket::add_data() {
  // @@protoc_insertion_point(field_add:DataPacket.data)
  return _internal_add_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataFrame >&
DataPacket::data() const {
  // @@protoc_insertion_point(field_list:DataPacket.data)
  return data_;
}

// -------------------------------------------------------------------

// RawCommand

// required bool all_sensors = 1;
inline bool RawCommand::_internal_has_all_sensors() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RawCommand::has_all_sensors() const {
  return _internal_has_all_sensors();
}
inline void RawCommand::clear_all_sensors() {
  all_sensors_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool RawCommand::_internal_all_sensors() const {
  return all_sensors_;
}
inline bool RawCommand::all_sensors() const {
  // @@protoc_insertion_point(field_get:RawCommand.all_sensors)
  return _internal_all_sensors();
}
inline void RawCommand::_internal_set_all_sensors(bool value) {
  _has_bits_[0] |= 0x00000001u;
  all_sensors_ = value;
}
inline void RawCommand::set_all_sensors(bool value) {
  _internal_set_all_sensors(value);
  // @@protoc_insertion_point(field_set:RawCommand.all_sensors)
}

// required uint32 sensor_num = 2;
inline bool RawCommand::_internal_has_sensor_num() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RawCommand::has_sensor_num() const {
  return _internal_has_sensor_num();
}
inline void RawCommand::clear_sensor_num() {
  sensor_num_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawCommand::_internal_sensor_num() const {
  return sensor_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawCommand::sensor_num() const {
  // @@protoc_insertion_point(field_get:RawCommand.sensor_num)
  return _internal_sensor_num();
}
inline void RawCommand::_internal_set_sensor_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  sensor_num_ = value;
}
inline void RawCommand::set_sensor_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_num(value);
  // @@protoc_insertion_point(field_set:RawCommand.sensor_num)
}

// required uint32 register_address = 3;
inline bool RawCommand::_internal_has_register_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RawCommand::has_register_address() const {
  return _internal_has_register_address();
}
inline void RawCommand::clear_register_address() {
  register_address_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawCommand::_internal_register_address() const {
  return register_address_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawCommand::register_address() const {
  // @@protoc_insertion_point(field_get:RawCommand.register_address)
  return _internal_register_address();
}
inline void RawCommand::_internal_set_register_address(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  register_address_ = value;
}
inline void RawCommand::set_register_address(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_register_address(value);
  // @@protoc_insertion_point(field_set:RawCommand.register_address)
}

// required uint32 data = 4;
inline bool RawCommand::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RawCommand::has_data() const {
  return _internal_has_data();
}
inline void RawCommand::clear_data() {
  data_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawCommand::_internal_data() const {
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawCommand::data() const {
  // @@protoc_insertion_point(field_get:RawCommand.data)
  return _internal_data();
}
inline void RawCommand::_internal_set_data(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  data_ = value;
}
inline void RawCommand::set_data(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:RawCommand.data)
}

// -------------------------------------------------------------------

// DevModeValidation

// optional string password = 1;
inline bool DevModeValidation::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevModeValidation::has_password() const {
  return _internal_has_password();
}
inline void DevModeValidation::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DevModeValidation::password() const {
  // @@protoc_insertion_point(field_get:DevModeValidation.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevModeValidation::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DevModeValidation.password)
}
inline std::string* DevModeValidation::mutable_password() {
  // @@protoc_insertion_point(field_mutable:DevModeValidation.password)
  return _internal_mutable_password();
}
inline const std::string& DevModeValidation::_internal_password() const {
  return password_.Get();
}
inline void DevModeValidation::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DevModeValidation::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DevModeValidation::release_password() {
  // @@protoc_insertion_point(field_release:DevModeValidation.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DevModeValidation::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DevModeValidation.password)
}

// optional bool valid = 2;
inline bool DevModeValidation::_internal_has_valid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DevModeValidation::has_valid() const {
  return _internal_has_valid();
}
inline void DevModeValidation::clear_valid() {
  valid_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DevModeValidation::_internal_valid() const {
  return valid_;
}
inline bool DevModeValidation::valid() const {
  // @@protoc_insertion_point(field_get:DevModeValidation.valid)
  return _internal_valid();
}
inline void DevModeValidation::_internal_set_valid(bool value) {
  _has_bits_[0] |= 0x00000002u;
  valid_ = value;
}
inline void DevModeValidation::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:DevModeValidation.valid)
}

// optional bool enable = 3;
inline bool DevModeValidation::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DevModeValidation::has_enable() const {
  return _internal_has_enable();
}
inline void DevModeValidation::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DevModeValidation::_internal_enable() const {
  return enable_;
}
inline bool DevModeValidation::enable() const {
  // @@protoc_insertion_point(field_get:DevModeValidation.enable)
  return _internal_enable();
}
inline void DevModeValidation::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_ = value;
}
inline void DevModeValidation::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:DevModeValidation.enable)
}

// -------------------------------------------------------------------

// ConfigMessage

// optional uint32 sensor_id = 1;
inline bool ConfigMessage::_internal_has_sensor_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigMessage::has_sensor_id() const {
  return _internal_has_sensor_id();
}
inline void ConfigMessage::clear_sensor_id() {
  sensor_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfigMessage::_internal_sensor_id() const {
  return sensor_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfigMessage::sensor_id() const {
  // @@protoc_insertion_point(field_get:ConfigMessage.sensor_id)
  return _internal_sensor_id();
}
inline void ConfigMessage::_internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sensor_id_ = value;
}
inline void ConfigMessage::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:ConfigMessage.sensor_id)
}

// optional uint32 datatype = 2;
inline bool ConfigMessage::_internal_has_datatype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigMessage::has_datatype() const {
  return _internal_has_datatype();
}
inline void ConfigMessage::clear_datatype() {
  datatype_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfigMessage::_internal_datatype() const {
  return datatype_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfigMessage::datatype() const {
  // @@protoc_insertion_point(field_get:ConfigMessage.datatype)
  return _internal_datatype();
}
inline void ConfigMessage::_internal_set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  datatype_ = value;
}
inline void ConfigMessage::set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:ConfigMessage.datatype)
}

// optional uint32 freq = 3;
inline bool ConfigMessage::_internal_has_freq() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigMessage::has_freq() const {
  return _internal_has_freq();
}
inline void ConfigMessage::clear_freq() {
  freq_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfigMessage::_internal_freq() const {
  return freq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfigMessage::freq() const {
  // @@protoc_insertion_point(field_get:ConfigMessage.freq)
  return _internal_freq();
}
inline void ConfigMessage::_internal_set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  freq_ = value;
}
inline void ConfigMessage::set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_freq(value);
  // @@protoc_insertion_point(field_set:ConfigMessage.freq)
}

// -------------------------------------------------------------------

// LogicMessage

// optional uint32 sensor_id = 1;
inline bool LogicMessage::_internal_has_sensor_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogicMessage::has_sensor_id() const {
  return _internal_has_sensor_id();
}
inline void LogicMessage::clear_sensor_id() {
  sensor_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicMessage::_internal_sensor_id() const {
  return sensor_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicMessage::sensor_id() const {
  // @@protoc_insertion_point(field_get:LogicMessage.sensor_id)
  return _internal_sensor_id();
}
inline void LogicMessage::_internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sensor_id_ = value;
}
inline void LogicMessage::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:LogicMessage.sensor_id)
}

// optional .LogicMessage.EnumLogicType type = 2;
inline bool LogicMessage::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LogicMessage::has_type() const {
  return _internal_has_type();
}
inline void LogicMessage::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::LogicMessage_EnumLogicType LogicMessage::_internal_type() const {
  return static_cast< ::LogicMessage_EnumLogicType >(type_);
}
inline ::LogicMessage_EnumLogicType LogicMessage::type() const {
  // @@protoc_insertion_point(field_get:LogicMessage.type)
  return _internal_type();
}
inline void LogicMessage::_internal_set_type(::LogicMessage_EnumLogicType value) {
  assert(::LogicMessage_EnumLogicType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void LogicMessage::set_type(::LogicMessage_EnumLogicType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:LogicMessage.type)
}

// repeated uint32 sensor_list = 3;
inline int LogicMessage::_internal_sensor_list_size() const {
  return sensor_list_.size();
}
inline int LogicMessage::sensor_list_size() const {
  return _internal_sensor_list_size();
}
inline void LogicMessage::clear_sensor_list() {
  sensor_list_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicMessage::_internal_sensor_list(int index) const {
  return sensor_list_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicMessage::sensor_list(int index) const {
  // @@protoc_insertion_point(field_get:LogicMessage.sensor_list)
  return _internal_sensor_list(index);
}
inline void LogicMessage::set_sensor_list(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  sensor_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:LogicMessage.sensor_list)
}
inline void LogicMessage::_internal_add_sensor_list(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  sensor_list_.Add(value);
}
inline void LogicMessage::add_sensor_list(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_sensor_list(value);
  // @@protoc_insertion_point(field_add:LogicMessage.sensor_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
LogicMessage::_internal_sensor_list() const {
  return sensor_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
LogicMessage::sensor_list() const {
  // @@protoc_insertion_point(field_list:LogicMessage.sensor_list)
  return _internal_sensor_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
LogicMessage::_internal_mutable_sensor_list() {
  return &sensor_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
LogicMessage::mutable_sensor_list() {
  // @@protoc_insertion_point(field_mutable_list:LogicMessage.sensor_list)
  return _internal_mutable_sensor_list();
}

// -------------------------------------------------------------------

// LogicInterruptMessage

// optional uint32 type = 1;
inline bool LogicInterruptMessage::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogicInterruptMessage::has_type() const {
  return _internal_has_type();
}
inline void LogicInterruptMessage::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicInterruptMessage::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicInterruptMessage::type() const {
  // @@protoc_insertion_point(field_get:LogicInterruptMessage.type)
  return _internal_type();
}
inline void LogicInterruptMessage::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void LogicInterruptMessage::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:LogicInterruptMessage.type)
}

// repeated uint32 sensor_list = 2;
inline int LogicInterruptMessage::_internal_sensor_list_size() const {
  return sensor_list_.size();
}
inline int LogicInterruptMessage::sensor_list_size() const {
  return _internal_sensor_list_size();
}
inline void LogicInterruptMessage::clear_sensor_list() {
  sensor_list_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicInterruptMessage::_internal_sensor_list(int index) const {
  return sensor_list_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LogicInterruptMessage::sensor_list(int index) const {
  // @@protoc_insertion_point(field_get:LogicInterruptMessage.sensor_list)
  return _internal_sensor_list(index);
}
inline void LogicInterruptMessage::set_sensor_list(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  sensor_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:LogicInterruptMessage.sensor_list)
}
inline void LogicInterruptMessage::_internal_add_sensor_list(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  sensor_list_.Add(value);
}
inline void LogicInterruptMessage::add_sensor_list(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_sensor_list(value);
  // @@protoc_insertion_point(field_add:LogicInterruptMessage.sensor_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
LogicInterruptMessage::_internal_sensor_list() const {
  return sensor_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
LogicInterruptMessage::sensor_list() const {
  // @@protoc_insertion_point(field_list:LogicInterruptMessage.sensor_list)
  return _internal_sensor_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
LogicInterruptMessage::_internal_mutable_sensor_list() {
  return &sensor_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
LogicInterruptMessage::mutable_sensor_list() {
  // @@protoc_insertion_point(field_mutable_list:LogicInterruptMessage.sensor_list)
  return _internal_mutable_sensor_list();
}

// -------------------------------------------------------------------

// WaveMessage

// optional uint32 sensor_id = 1;
inline bool WaveMessage::_internal_has_sensor_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WaveMessage::has_sensor_id() const {
  return _internal_has_sensor_id();
}
inline void WaveMessage::clear_sensor_id() {
  sensor_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WaveMessage::_internal_sensor_id() const {
  return sensor_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WaveMessage::sensor_id() const {
  // @@protoc_insertion_point(field_get:WaveMessage.sensor_id)
  return _internal_sensor_id();
}
inline void WaveMessage::_internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sensor_id_ = value;
}
inline void WaveMessage::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:WaveMessage.sensor_id)
}

// optional float freq = 2;
inline bool WaveMessage::_internal_has_freq() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WaveMessage::has_freq() const {
  return _internal_has_freq();
}
inline void WaveMessage::clear_freq() {
  freq_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float WaveMessage::_internal_freq() const {
  return freq_;
}
inline float WaveMessage::freq() const {
  // @@protoc_insertion_point(field_get:WaveMessage.freq)
  return _internal_freq();
}
inline void WaveMessage::_internal_set_freq(float value) {
  _has_bits_[0] |= 0x00000002u;
  freq_ = value;
}
inline void WaveMessage::set_freq(float value) {
  _internal_set_freq(value);
  // @@protoc_insertion_point(field_set:WaveMessage.freq)
}

// optional float amp = 3;
inline bool WaveMessage::_internal_has_amp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WaveMessage::has_amp() const {
  return _internal_has_amp();
}
inline void WaveMessage::clear_amp() {
  amp_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float WaveMessage::_internal_amp() const {
  return amp_;
}
inline float WaveMessage::amp() const {
  // @@protoc_insertion_point(field_get:WaveMessage.amp)
  return _internal_amp();
}
inline void WaveMessage::_internal_set_amp(float value) {
  _has_bits_[0] |= 0x00000004u;
  amp_ = value;
}
inline void WaveMessage::set_amp(float value) {
  _internal_set_amp(value);
  // @@protoc_insertion_point(field_set:WaveMessage.amp)
}

// optional uint32 type = 4;
inline bool WaveMessage::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WaveMessage::has_type() const {
  return _internal_has_type();
}
inline void WaveMessage::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WaveMessage::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WaveMessage::type() const {
  // @@protoc_insertion_point(field_get:WaveMessage.type)
  return _internal_type();
}
inline void WaveMessage::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void WaveMessage::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:WaveMessage.type)
}

// -------------------------------------------------------------------

// CmdPacket

// required .CmdPacket.EnumCmdType cmd = 1;
inline bool CmdPacket::_internal_has_cmd() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CmdPacket::has_cmd() const {
  return _internal_has_cmd();
}
inline void CmdPacket::clear_cmd() {
  cmd_ = 2;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::CmdPacket_EnumCmdType CmdPacket::_internal_cmd() const {
  return static_cast< ::CmdPacket_EnumCmdType >(cmd_);
}
inline ::CmdPacket_EnumCmdType CmdPacket::cmd() const {
  // @@protoc_insertion_point(field_get:CmdPacket.cmd)
  return _internal_cmd();
}
inline void CmdPacket::_internal_set_cmd(::CmdPacket_EnumCmdType value) {
  assert(::CmdPacket_EnumCmdType_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  cmd_ = value;
}
inline void CmdPacket::set_cmd(::CmdPacket_EnumCmdType value) {
  _internal_set_cmd(value);
  // @@protoc_insertion_point(field_set:CmdPacket.cmd)
}

// optional uint32 sensor_id = 2;
inline bool CmdPacket::_internal_has_sensor_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CmdPacket::has_sensor_id() const {
  return _internal_has_sensor_id();
}
inline void CmdPacket::clear_sensor_id() {
  sensor_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdPacket::_internal_sensor_id() const {
  return sensor_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdPacket::sensor_id() const {
  // @@protoc_insertion_point(field_get:CmdPacket.sensor_id)
  return _internal_sensor_id();
}
inline void CmdPacket::_internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  sensor_id_ = value;
}
inline void CmdPacket::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:CmdPacket.sensor_id)
}

// optional uint32 datatype = 3;
inline bool CmdPacket::_internal_has_datatype() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CmdPacket::has_datatype() const {
  return _internal_has_datatype();
}
inline void CmdPacket::clear_datatype() {
  datatype_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdPacket::_internal_datatype() const {
  return datatype_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdPacket::datatype() const {
  // @@protoc_insertion_point(field_get:CmdPacket.datatype)
  return _internal_datatype();
}
inline void CmdPacket::_internal_set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  datatype_ = value;
}
inline void CmdPacket::set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:CmdPacket.datatype)
}

// optional uint32 freq = 4;
inline bool CmdPacket::_internal_has_freq() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CmdPacket::has_freq() const {
  return _internal_has_freq();
}
inline void CmdPacket::clear_freq() {
  freq_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdPacket::_internal_freq() const {
  return freq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdPacket::freq() const {
  // @@protoc_insertion_point(field_get:CmdPacket.freq)
  return _internal_freq();
}
inline void CmdPacket::_internal_set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  freq_ = value;
}
inline void CmdPacket::set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_freq(value);
  // @@protoc_insertion_point(field_set:CmdPacket.freq)
}

// optional .RawCommand raw_cmd = 5;
inline bool CmdPacket::_internal_has_raw_cmd() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || raw_cmd_ != nullptr);
  return value;
}
inline bool CmdPacket::has_raw_cmd() const {
  return _internal_has_raw_cmd();
}
inline void CmdPacket::clear_raw_cmd() {
  if (raw_cmd_ != nullptr) raw_cmd_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::RawCommand& CmdPacket::_internal_raw_cmd() const {
  const ::RawCommand* p = raw_cmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::RawCommand&>(
      ::_RawCommand_default_instance_);
}
inline const ::RawCommand& CmdPacket::raw_cmd() const {
  // @@protoc_insertion_point(field_get:CmdPacket.raw_cmd)
  return _internal_raw_cmd();
}
inline void CmdPacket::unsafe_arena_set_allocated_raw_cmd(
    ::RawCommand* raw_cmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_cmd_);
  }
  raw_cmd_ = raw_cmd;
  if (raw_cmd) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CmdPacket.raw_cmd)
}
inline ::RawCommand* CmdPacket::release_raw_cmd() {
  _has_bits_[0] &= ~0x00000002u;
  ::RawCommand* temp = raw_cmd_;
  raw_cmd_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RawCommand* CmdPacket::unsafe_arena_release_raw_cmd() {
  // @@protoc_insertion_point(field_release:CmdPacket.raw_cmd)
  _has_bits_[0] &= ~0x00000002u;
  ::RawCommand* temp = raw_cmd_;
  raw_cmd_ = nullptr;
  return temp;
}
inline ::RawCommand* CmdPacket::_internal_mutable_raw_cmd() {
  _has_bits_[0] |= 0x00000002u;
  if (raw_cmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::RawCommand>(GetArenaForAllocation());
    raw_cmd_ = p;
  }
  return raw_cmd_;
}
inline ::RawCommand* CmdPacket::mutable_raw_cmd() {
  // @@protoc_insertion_point(field_mutable:CmdPacket.raw_cmd)
  return _internal_mutable_raw_cmd();
}
inline void CmdPacket::set_allocated_raw_cmd(::RawCommand* raw_cmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete raw_cmd_;
  }
  if (raw_cmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RawCommand>::GetOwningArena(raw_cmd);
    if (message_arena != submessage_arena) {
      raw_cmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_cmd, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  raw_cmd_ = raw_cmd;
  // @@protoc_insertion_point(field_set_allocated:CmdPacket.raw_cmd)
}

// optional string uri = 6;
inline bool CmdPacket::_internal_has_uri() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CmdPacket::has_uri() const {
  return _internal_has_uri();
}
inline void CmdPacket::clear_uri() {
  uri_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CmdPacket::uri() const {
  // @@protoc_insertion_point(field_get:CmdPacket.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CmdPacket::set_uri(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CmdPacket.uri)
}
inline std::string* CmdPacket::mutable_uri() {
  // @@protoc_insertion_point(field_mutable:CmdPacket.uri)
  return _internal_mutable_uri();
}
inline const std::string& CmdPacket::_internal_uri() const {
  return uri_.Get();
}
inline void CmdPacket::_internal_set_uri(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CmdPacket::_internal_mutable_uri() {
  _has_bits_[0] |= 0x00000001u;
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CmdPacket::release_uri() {
  // @@protoc_insertion_point(field_release:CmdPacket.uri)
  if (!_internal_has_uri()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return uri_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CmdPacket::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CmdPacket.uri)
}

// repeated .ConfigMessage config_list = 7;
inline int CmdPacket::_internal_config_list_size() const {
  return config_list_.size();
}
inline int CmdPacket::config_list_size() const {
  return _internal_config_list_size();
}
inline void CmdPacket::clear_config_list() {
  config_list_.Clear();
}
inline ::ConfigMessage* CmdPacket::mutable_config_list(int index) {
  // @@protoc_insertion_point(field_mutable:CmdPacket.config_list)
  return config_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ConfigMessage >*
CmdPacket::mutable_config_list() {
  // @@protoc_insertion_point(field_mutable_list:CmdPacket.config_list)
  return &config_list_;
}
inline const ::ConfigMessage& CmdPacket::_internal_config_list(int index) const {
  return config_list_.Get(index);
}
inline const ::ConfigMessage& CmdPacket::config_list(int index) const {
  // @@protoc_insertion_point(field_get:CmdPacket.config_list)
  return _internal_config_list(index);
}
inline ::ConfigMessage* CmdPacket::_internal_add_config_list() {
  return config_list_.Add();
}
inline ::ConfigMessage* CmdPacket::add_config_list() {
  // @@protoc_insertion_point(field_add:CmdPacket.config_list)
  return _internal_add_config_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ConfigMessage >&
CmdPacket::config_list() const {
  // @@protoc_insertion_point(field_list:CmdPacket.config_list)
  return config_list_;
}

// optional .DevModeValidation dev_mode = 8;
inline bool CmdPacket::_internal_has_dev_mode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || dev_mode_ != nullptr);
  return value;
}
inline bool CmdPacket::has_dev_mode() const {
  return _internal_has_dev_mode();
}
inline void CmdPacket::clear_dev_mode() {
  if (dev_mode_ != nullptr) dev_mode_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::DevModeValidation& CmdPacket::_internal_dev_mode() const {
  const ::DevModeValidation* p = dev_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::DevModeValidation&>(
      ::_DevModeValidation_default_instance_);
}
inline const ::DevModeValidation& CmdPacket::dev_mode() const {
  // @@protoc_insertion_point(field_get:CmdPacket.dev_mode)
  return _internal_dev_mode();
}
inline void CmdPacket::unsafe_arena_set_allocated_dev_mode(
    ::DevModeValidation* dev_mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dev_mode_);
  }
  dev_mode_ = dev_mode;
  if (dev_mode) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CmdPacket.dev_mode)
}
inline ::DevModeValidation* CmdPacket::release_dev_mode() {
  _has_bits_[0] &= ~0x00000004u;
  ::DevModeValidation* temp = dev_mode_;
  dev_mode_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::DevModeValidation* CmdPacket::unsafe_arena_release_dev_mode() {
  // @@protoc_insertion_point(field_release:CmdPacket.dev_mode)
  _has_bits_[0] &= ~0x00000004u;
  ::DevModeValidation* temp = dev_mode_;
  dev_mode_ = nullptr;
  return temp;
}
inline ::DevModeValidation* CmdPacket::_internal_mutable_dev_mode() {
  _has_bits_[0] |= 0x00000004u;
  if (dev_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::DevModeValidation>(GetArenaForAllocation());
    dev_mode_ = p;
  }
  return dev_mode_;
}
inline ::DevModeValidation* CmdPacket::mutable_dev_mode() {
  // @@protoc_insertion_point(field_mutable:CmdPacket.dev_mode)
  return _internal_mutable_dev_mode();
}
inline void CmdPacket::set_allocated_dev_mode(::DevModeValidation* dev_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dev_mode_;
  }
  if (dev_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::DevModeValidation>::GetOwningArena(dev_mode);
    if (message_arena != submessage_arena) {
      dev_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dev_mode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  dev_mode_ = dev_mode;
  // @@protoc_insertion_point(field_set_allocated:CmdPacket.dev_mode)
}

// repeated .LogicMessage logic_req = 9;
inline int CmdPacket::_internal_logic_req_size() const {
  return logic_req_.size();
}
inline int CmdPacket::logic_req_size() const {
  return _internal_logic_req_size();
}
inline void CmdPacket::clear_logic_req() {
  logic_req_.Clear();
}
inline ::LogicMessage* CmdPacket::mutable_logic_req(int index) {
  // @@protoc_insertion_point(field_mutable:CmdPacket.logic_req)
  return logic_req_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicMessage >*
CmdPacket::mutable_logic_req() {
  // @@protoc_insertion_point(field_mutable_list:CmdPacket.logic_req)
  return &logic_req_;
}
inline const ::LogicMessage& CmdPacket::_internal_logic_req(int index) const {
  return logic_req_.Get(index);
}
inline const ::LogicMessage& CmdPacket::logic_req(int index) const {
  // @@protoc_insertion_point(field_get:CmdPacket.logic_req)
  return _internal_logic_req(index);
}
inline ::LogicMessage* CmdPacket::_internal_add_logic_req() {
  return logic_req_.Add();
}
inline ::LogicMessage* CmdPacket::add_logic_req() {
  // @@protoc_insertion_point(field_add:CmdPacket.logic_req)
  return _internal_add_logic_req();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicMessage >&
CmdPacket::logic_req() const {
  // @@protoc_insertion_point(field_list:CmdPacket.logic_req)
  return logic_req_;
}

// repeated .WaveMessage wave_req = 10;
inline int CmdPacket::_internal_wave_req_size() const {
  return wave_req_.size();
}
inline int CmdPacket::wave_req_size() const {
  return _internal_wave_req_size();
}
inline void CmdPacket::clear_wave_req() {
  wave_req_.Clear();
}
inline ::WaveMessage* CmdPacket::mutable_wave_req(int index) {
  // @@protoc_insertion_point(field_mutable:CmdPacket.wave_req)
  return wave_req_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WaveMessage >*
CmdPacket::mutable_wave_req() {
  // @@protoc_insertion_point(field_mutable_list:CmdPacket.wave_req)
  return &wave_req_;
}
inline const ::WaveMessage& CmdPacket::_internal_wave_req(int index) const {
  return wave_req_.Get(index);
}
inline const ::WaveMessage& CmdPacket::wave_req(int index) const {
  // @@protoc_insertion_point(field_get:CmdPacket.wave_req)
  return _internal_wave_req(index);
}
inline ::WaveMessage* CmdPacket::_internal_add_wave_req() {
  return wave_req_.Add();
}
inline ::WaveMessage* CmdPacket::add_wave_req() {
  // @@protoc_insertion_point(field_add:CmdPacket.wave_req)
  return _internal_add_wave_req();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WaveMessage >&
CmdPacket::wave_req() const {
  // @@protoc_insertion_point(field_list:CmdPacket.wave_req)
  return wave_req_;
}

// optional bool chassis_ident = 11;
inline bool CmdPacket::_internal_has_chassis_ident() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CmdPacket::has_chassis_ident() const {
  return _internal_has_chassis_ident();
}
inline void CmdPacket::clear_chassis_ident() {
  chassis_ident_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CmdPacket::_internal_chassis_ident() const {
  return chassis_ident_;
}
inline bool CmdPacket::chassis_ident() const {
  // @@protoc_insertion_point(field_get:CmdPacket.chassis_ident)
  return _internal_chassis_ident();
}
inline void CmdPacket::_internal_set_chassis_ident(bool value) {
  _has_bits_[0] |= 0x00000040u;
  chassis_ident_ = value;
}
inline void CmdPacket::set_chassis_ident(bool value) {
  _internal_set_chassis_ident(value);
  // @@protoc_insertion_point(field_set:CmdPacket.chassis_ident)
}

// optional bool closed_loop = 12;
inline bool CmdPacket::_internal_has_closed_loop() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CmdPacket::has_closed_loop() const {
  return _internal_has_closed_loop();
}
inline void CmdPacket::clear_closed_loop() {
  closed_loop_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CmdPacket::_internal_closed_loop() const {
  return closed_loop_;
}
inline bool CmdPacket::closed_loop() const {
  // @@protoc_insertion_point(field_get:CmdPacket.closed_loop)
  return _internal_closed_loop();
}
inline void CmdPacket::_internal_set_closed_loop(bool value) {
  _has_bits_[0] |= 0x00000080u;
  closed_loop_ = value;
}
inline void CmdPacket::set_closed_loop(bool value) {
  _internal_set_closed_loop(value);
  // @@protoc_insertion_point(field_set:CmdPacket.closed_loop)
}

// repeated .LogicInterruptMessage logic_interrupt_req = 13;
inline int CmdPacket::_internal_logic_interrupt_req_size() const {
  return logic_interrupt_req_.size();
}
inline int CmdPacket::logic_interrupt_req_size() const {
  return _internal_logic_interrupt_req_size();
}
inline void CmdPacket::clear_logic_interrupt_req() {
  logic_interrupt_req_.Clear();
}
inline ::LogicInterruptMessage* CmdPacket::mutable_logic_interrupt_req(int index) {
  // @@protoc_insertion_point(field_mutable:CmdPacket.logic_interrupt_req)
  return logic_interrupt_req_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicInterruptMessage >*
CmdPacket::mutable_logic_interrupt_req() {
  // @@protoc_insertion_point(field_mutable_list:CmdPacket.logic_interrupt_req)
  return &logic_interrupt_req_;
}
inline const ::LogicInterruptMessage& CmdPacket::_internal_logic_interrupt_req(int index) const {
  return logic_interrupt_req_.Get(index);
}
inline const ::LogicInterruptMessage& CmdPacket::logic_interrupt_req(int index) const {
  // @@protoc_insertion_point(field_get:CmdPacket.logic_interrupt_req)
  return _internal_logic_interrupt_req(index);
}
inline ::LogicInterruptMessage* CmdPacket::_internal_add_logic_interrupt_req() {
  return logic_interrupt_req_.Add();
}
inline ::LogicInterruptMessage* CmdPacket::add_logic_interrupt_req() {
  // @@protoc_insertion_point(field_add:CmdPacket.logic_interrupt_req)
  return _internal_add_logic_interrupt_req();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogicInterruptMessage >&
CmdPacket::logic_interrupt_req() const {
  // @@protoc_insertion_point(field_list:CmdPacket.logic_interrupt_req)
  return logic_interrupt_req_;
}

// optional uint32 num_sync_chassis = 14;
inline bool CmdPacket::_internal_has_num_sync_chassis() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CmdPacket::has_num_sync_chassis() const {
  return _internal_has_num_sync_chassis();
}
inline void CmdPacket::clear_num_sync_chassis() {
  num_sync_chassis_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdPacket::_internal_num_sync_chassis() const {
  return num_sync_chassis_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdPacket::num_sync_chassis() const {
  // @@protoc_insertion_point(field_get:CmdPacket.num_sync_chassis)
  return _internal_num_sync_chassis();
}
inline void CmdPacket::_internal_set_num_sync_chassis(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  num_sync_chassis_ = value;
}
inline void CmdPacket::set_num_sync_chassis(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_sync_chassis(value);
  // @@protoc_insertion_point(field_set:CmdPacket.num_sync_chassis)
}

// -------------------------------------------------------------------

// SensorStatus

// required uint32 sensor_id = 1;
inline bool SensorStatus::_internal_has_sensor_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SensorStatus::has_sensor_id() const {
  return _internal_has_sensor_id();
}
inline void SensorStatus::clear_sensor_id() {
  sensor_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorStatus::_internal_sensor_id() const {
  return sensor_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorStatus::sensor_id() const {
  // @@protoc_insertion_point(field_get:SensorStatus.sensor_id)
  return _internal_sensor_id();
}
inline void SensorStatus::_internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  sensor_id_ = value;
}
inline void SensorStatus::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:SensorStatus.sensor_id)
}

// optional string sensor_card_serial_num = 2;
inline bool SensorStatus::_internal_has_sensor_card_serial_num() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorStatus::has_sensor_card_serial_num() const {
  return _internal_has_sensor_card_serial_num();
}
inline void SensorStatus::clear_sensor_card_serial_num() {
  sensor_card_serial_num_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SensorStatus::sensor_card_serial_num() const {
  // @@protoc_insertion_point(field_get:SensorStatus.sensor_card_serial_num)
  return _internal_sensor_card_serial_num();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorStatus::set_sensor_card_serial_num(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sensor_card_serial_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorStatus.sensor_card_serial_num)
}
inline std::string* SensorStatus::mutable_sensor_card_serial_num() {
  // @@protoc_insertion_point(field_mutable:SensorStatus.sensor_card_serial_num)
  return _internal_mutable_sensor_card_serial_num();
}
inline const std::string& SensorStatus::_internal_sensor_card_serial_num() const {
  return sensor_card_serial_num_.Get();
}
inline void SensorStatus::_internal_set_sensor_card_serial_num(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sensor_card_serial_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SensorStatus::_internal_mutable_sensor_card_serial_num() {
  _has_bits_[0] |= 0x00000001u;
  return sensor_card_serial_num_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SensorStatus::release_sensor_card_serial_num() {
  // @@protoc_insertion_point(field_release:SensorStatus.sensor_card_serial_num)
  if (!_internal_has_sensor_card_serial_num()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sensor_card_serial_num_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SensorStatus::set_allocated_sensor_card_serial_num(std::string* sensor_card_serial_num) {
  if (sensor_card_serial_num != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sensor_card_serial_num_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensor_card_serial_num,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SensorStatus.sensor_card_serial_num)
}

// optional string sensor_version = 3;
inline bool SensorStatus::_internal_has_sensor_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorStatus::has_sensor_version() const {
  return _internal_has_sensor_version();
}
inline void SensorStatus::clear_sensor_version() {
  sensor_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SensorStatus::sensor_version() const {
  // @@protoc_insertion_point(field_get:SensorStatus.sensor_version)
  return _internal_sensor_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorStatus::set_sensor_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sensor_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorStatus.sensor_version)
}
inline std::string* SensorStatus::mutable_sensor_version() {
  // @@protoc_insertion_point(field_mutable:SensorStatus.sensor_version)
  return _internal_mutable_sensor_version();
}
inline const std::string& SensorStatus::_internal_sensor_version() const {
  return sensor_version_.Get();
}
inline void SensorStatus::_internal_set_sensor_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sensor_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SensorStatus::_internal_mutable_sensor_version() {
  _has_bits_[0] |= 0x00000002u;
  return sensor_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SensorStatus::release_sensor_version() {
  // @@protoc_insertion_point(field_release:SensorStatus.sensor_version)
  if (!_internal_has_sensor_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sensor_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SensorStatus::set_allocated_sensor_version(std::string* sensor_version) {
  if (sensor_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sensor_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensor_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SensorStatus.sensor_version)
}

// optional bool sensor_connected = 4;
inline bool SensorStatus::_internal_has_sensor_connected() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SensorStatus::has_sensor_connected() const {
  return _internal_has_sensor_connected();
}
inline void SensorStatus::clear_sensor_connected() {
  sensor_connected_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool SensorStatus::_internal_sensor_connected() const {
  return sensor_connected_;
}
inline bool SensorStatus::sensor_connected() const {
  // @@protoc_insertion_point(field_get:SensorStatus.sensor_connected)
  return _internal_sensor_connected();
}
inline void SensorStatus::_internal_set_sensor_connected(bool value) {
  _has_bits_[0] |= 0x00000010u;
  sensor_connected_ = value;
}
inline void SensorStatus::set_sensor_connected(bool value) {
  _internal_set_sensor_connected(value);
  // @@protoc_insertion_point(field_set:SensorStatus.sensor_connected)
}

// optional string sensor_serial_num = 5;
inline bool SensorStatus::_internal_has_sensor_serial_num() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorStatus::has_sensor_serial_num() const {
  return _internal_has_sensor_serial_num();
}
inline void SensorStatus::clear_sensor_serial_num() {
  sensor_serial_num_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SensorStatus::sensor_serial_num() const {
  // @@protoc_insertion_point(field_get:SensorStatus.sensor_serial_num)
  return _internal_sensor_serial_num();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorStatus::set_sensor_serial_num(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 sensor_serial_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorStatus.sensor_serial_num)
}
inline std::string* SensorStatus::mutable_sensor_serial_num() {
  // @@protoc_insertion_point(field_mutable:SensorStatus.sensor_serial_num)
  return _internal_mutable_sensor_serial_num();
}
inline const std::string& SensorStatus::_internal_sensor_serial_num() const {
  return sensor_serial_num_.Get();
}
inline void SensorStatus::_internal_set_sensor_serial_num(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sensor_serial_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SensorStatus::_internal_mutable_sensor_serial_num() {
  _has_bits_[0] |= 0x00000004u;
  return sensor_serial_num_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SensorStatus::release_sensor_serial_num() {
  // @@protoc_insertion_point(field_release:SensorStatus.sensor_serial_num)
  if (!_internal_has_sensor_serial_num()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return sensor_serial_num_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SensorStatus::set_allocated_sensor_serial_num(std::string* sensor_serial_num) {
  if (sensor_serial_num != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sensor_serial_num_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensor_serial_num,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SensorStatus.sensor_serial_num)
}

// -------------------------------------------------------------------

// SensorState

// optional uint32 sensor_id = 1;
inline bool SensorState::_internal_has_sensor_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorState::has_sensor_id() const {
  return _internal_has_sensor_id();
}
inline void SensorState::clear_sensor_id() {
  sensor_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorState::_internal_sensor_id() const {
  return sensor_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorState::sensor_id() const {
  // @@protoc_insertion_point(field_get:SensorState.sensor_id)
  return _internal_sensor_id();
}
inline void SensorState::_internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sensor_id_ = value;
}
inline void SensorState::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:SensorState.sensor_id)
}

// optional .SensorState.EnumStateType state = 2;
inline bool SensorState::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorState::has_state() const {
  return _internal_has_state();
}
inline void SensorState::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SensorState_EnumStateType SensorState::_internal_state() const {
  return static_cast< ::SensorState_EnumStateType >(state_);
}
inline ::SensorState_EnumStateType SensorState::state() const {
  // @@protoc_insertion_point(field_get:SensorState.state)
  return _internal_state();
}
inline void SensorState::_internal_set_state(::SensorState_EnumStateType value) {
  assert(::SensorState_EnumStateType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  state_ = value;
}
inline void SensorState::set_state(::SensorState_EnumStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:SensorState.state)
}

// optional uint32 error_flags = 3;
inline bool SensorState::_internal_has_error_flags() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorState::has_error_flags() const {
  return _internal_has_error_flags();
}
inline void SensorState::clear_error_flags() {
  error_flags_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorState::_internal_error_flags() const {
  return error_flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorState::error_flags() const {
  // @@protoc_insertion_point(field_get:SensorState.error_flags)
  return _internal_error_flags();
}
inline void SensorState::_internal_set_error_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  error_flags_ = value;
}
inline void SensorState::set_error_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_error_flags(value);
  // @@protoc_insertion_point(field_set:SensorState.error_flags)
}

// -------------------------------------------------------------------

// SensorConfig

// required uint32 sensor = 1;
inline bool SensorConfig::_internal_has_sensor() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorConfig::has_sensor() const {
  return _internal_has_sensor();
}
inline void SensorConfig::clear_sensor() {
  sensor_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorConfig::_internal_sensor() const {
  return sensor_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorConfig::sensor() const {
  // @@protoc_insertion_point(field_get:SensorConfig.sensor)
  return _internal_sensor();
}
inline void SensorConfig::_internal_set_sensor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sensor_ = value;
}
inline void SensorConfig::set_sensor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor(value);
  // @@protoc_insertion_point(field_set:SensorConfig.sensor)
}

// required uint32 datatype = 2;
inline bool SensorConfig::_internal_has_datatype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorConfig::has_datatype() const {
  return _internal_has_datatype();
}
inline void SensorConfig::clear_datatype() {
  datatype_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorConfig::_internal_datatype() const {
  return datatype_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorConfig::datatype() const {
  // @@protoc_insertion_point(field_get:SensorConfig.datatype)
  return _internal_datatype();
}
inline void SensorConfig::_internal_set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  datatype_ = value;
}
inline void SensorConfig::set_datatype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:SensorConfig.datatype)
}

// required uint32 freq = 3;
inline bool SensorConfig::_internal_has_freq() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorConfig::has_freq() const {
  return _internal_has_freq();
}
inline void SensorConfig::clear_freq() {
  freq_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorConfig::_internal_freq() const {
  return freq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorConfig::freq() const {
  // @@protoc_insertion_point(field_get:SensorConfig.freq)
  return _internal_freq();
}
inline void SensorConfig::_internal_set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  freq_ = value;
}
inline void SensorConfig::set_freq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_freq(value);
  // @@protoc_insertion_point(field_set:SensorConfig.freq)
}

// optional float calibration = 4;
inline bool SensorConfig::_internal_has_calibration() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SensorConfig::has_calibration() const {
  return _internal_has_calibration();
}
inline void SensorConfig::clear_calibration() {
  calibration_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float SensorConfig::_internal_calibration() const {
  return calibration_;
}
inline float SensorConfig::calibration() const {
  // @@protoc_insertion_point(field_get:SensorConfig.calibration)
  return _internal_calibration();
}
inline void SensorConfig::_internal_set_calibration(float value) {
  _has_bits_[0] |= 0x00000008u;
  calibration_ = value;
}
inline void SensorConfig::set_calibration(float value) {
  _internal_set_calibration(value);
  // @@protoc_insertion_point(field_set:SensorConfig.calibration)
}

// -------------------------------------------------------------------

// SensorLed

// optional uint32 sensor_id = 1;
inline bool SensorLed::_internal_has_sensor_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorLed::has_sensor_id() const {
  return _internal_has_sensor_id();
}
inline void SensorLed::clear_sensor_id() {
  sensor_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorLed::_internal_sensor_id() const {
  return sensor_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorLed::sensor_id() const {
  // @@protoc_insertion_point(field_get:SensorLed.sensor_id)
  return _internal_sensor_id();
}
inline void SensorLed::_internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sensor_id_ = value;
}
inline void SensorLed::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:SensorLed.sensor_id)
}

// optional uint32 blink_state = 2;
inline bool SensorLed::_internal_has_blink_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorLed::has_blink_state() const {
  return _internal_has_blink_state();
}
inline void SensorLed::clear_blink_state() {
  blink_state_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorLed::_internal_blink_state() const {
  return blink_state_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorLed::blink_state() const {
  // @@protoc_insertion_point(field_get:SensorLed.blink_state)
  return _internal_blink_state();
}
inline void SensorLed::_internal_set_blink_state(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  blink_state_ = value;
}
inline void SensorLed::set_blink_state(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_blink_state(value);
  // @@protoc_insertion_point(field_set:SensorLed.blink_state)
}

// optional uint32 color = 3;
inline bool SensorLed::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorLed::has_color() const {
  return _internal_has_color();
}
inline void SensorLed::clear_color() {
  color_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorLed::_internal_color() const {
  return color_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorLed::color() const {
  // @@protoc_insertion_point(field_get:SensorLed.color)
  return _internal_color();
}
inline void SensorLed::_internal_set_color(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  color_ = value;
}
inline void SensorLed::set_color(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:SensorLed.color)
}

// -------------------------------------------------------------------

// SensorField

// optional uint32 sensor_id = 1;
inline bool SensorField::_internal_has_sensor_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorField::has_sensor_id() const {
  return _internal_has_sensor_id();
}
inline void SensorField::clear_sensor_id() {
  sensor_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorField::_internal_sensor_id() const {
  return sensor_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorField::sensor_id() const {
  // @@protoc_insertion_point(field_get:SensorField.sensor_id)
  return _internal_sensor_id();
}
inline void SensorField::_internal_set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sensor_id_ = value;
}
inline void SensorField::set_sensor_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:SensorField.sensor_id)
}

// optional float field_x = 2;
inline bool SensorField::_internal_has_field_x() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorField::has_field_x() const {
  return _internal_has_field_x();
}
inline void SensorField::clear_field_x() {
  field_x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float SensorField::_internal_field_x() const {
  return field_x_;
}
inline float SensorField::field_x() const {
  // @@protoc_insertion_point(field_get:SensorField.field_x)
  return _internal_field_x();
}
inline void SensorField::_internal_set_field_x(float value) {
  _has_bits_[0] |= 0x00000002u;
  field_x_ = value;
}
inline void SensorField::set_field_x(float value) {
  _internal_set_field_x(value);
  // @@protoc_insertion_point(field_set:SensorField.field_x)
}

// optional float field_y = 3;
inline bool SensorField::_internal_has_field_y() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorField::has_field_y() const {
  return _internal_has_field_y();
}
inline void SensorField::clear_field_y() {
  field_y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float SensorField::_internal_field_y() const {
  return field_y_;
}
inline float SensorField::field_y() const {
  // @@protoc_insertion_point(field_get:SensorField.field_y)
  return _internal_field_y();
}
inline void SensorField::_internal_set_field_y(float value) {
  _has_bits_[0] |= 0x00000004u;
  field_y_ = value;
}
inline void SensorField::set_field_y(float value) {
  _internal_set_field_y(value);
  // @@protoc_insertion_point(field_set:SensorField.field_y)
}

// optional float field_z = 4;
inline bool SensorField::_internal_has_field_z() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SensorField::has_field_z() const {
  return _internal_has_field_z();
}
inline void SensorField::clear_field_z() {
  field_z_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float SensorField::_internal_field_z() const {
  return field_z_;
}
inline float SensorField::field_z() const {
  // @@protoc_insertion_point(field_get:SensorField.field_z)
  return _internal_field_z();
}
inline void SensorField::_internal_set_field_z(float value) {
  _has_bits_[0] |= 0x00000008u;
  field_z_ = value;
}
inline void SensorField::set_field_z(float value) {
  _internal_set_field_z(value);
  // @@protoc_insertion_point(field_set:SensorField.field_z)
}

// -------------------------------------------------------------------

// ChassisStatus

// optional bool closed_loop = 1;
inline bool ChassisStatus::_internal_has_closed_loop() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChassisStatus::has_closed_loop() const {
  return _internal_has_closed_loop();
}
inline void ChassisStatus::clear_closed_loop() {
  closed_loop_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ChassisStatus::_internal_closed_loop() const {
  return closed_loop_;
}
inline bool ChassisStatus::closed_loop() const {
  // @@protoc_insertion_point(field_get:ChassisStatus.closed_loop)
  return _internal_closed_loop();
}
inline void ChassisStatus::_internal_set_closed_loop(bool value) {
  _has_bits_[0] |= 0x00000001u;
  closed_loop_ = value;
}
inline void ChassisStatus::set_closed_loop(bool value) {
  _internal_set_closed_loop(value);
  // @@protoc_insertion_point(field_set:ChassisStatus.closed_loop)
}

// -------------------------------------------------------------------

// SystemStatusMessage

// optional uint32 num = 1;
inline bool SystemStatusMessage::_internal_has_num() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SystemStatusMessage::has_num() const {
  return _internal_has_num();
}
inline void SystemStatusMessage::clear_num() {
  num_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SystemStatusMessage::_internal_num() const {
  return num_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SystemStatusMessage::num() const {
  // @@protoc_insertion_point(field_get:SystemStatusMessage.num)
  return _internal_num();
}
inline void SystemStatusMessage::_internal_set_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  num_ = value;
}
inline void SystemStatusMessage::set_num(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:SystemStatusMessage.num)
}

// optional uint32 total = 2;
inline bool SystemStatusMessage::_internal_has_total() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SystemStatusMessage::has_total() const {
  return _internal_has_total();
}
inline void SystemStatusMessage::clear_total() {
  total_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SystemStatusMessage::_internal_total() const {
  return total_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SystemStatusMessage::total() const {
  // @@protoc_insertion_point(field_get:SystemStatusMessage.total)
  return _internal_total();
}
inline void SystemStatusMessage::_internal_set_total(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  total_ = value;
}
inline void SystemStatusMessage::set_total(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:SystemStatusMessage.total)
}

// optional string version = 3;
inline bool SystemStatusMessage::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SystemStatusMessage::has_version() const {
  return _internal_has_version();
}
inline void SystemStatusMessage::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SystemStatusMessage::version() const {
  // @@protoc_insertion_point(field_get:SystemStatusMessage.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatusMessage::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemStatusMessage.version)
}
inline std::string* SystemStatusMessage::mutable_version() {
  // @@protoc_insertion_point(field_mutable:SystemStatusMessage.version)
  return _internal_mutable_version();
}
inline const std::string& SystemStatusMessage::_internal_version() const {
  return version_.Get();
}
inline void SystemStatusMessage::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SystemStatusMessage::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SystemStatusMessage::release_version() {
  // @@protoc_insertion_point(field_release:SystemStatusMessage.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SystemStatusMessage::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SystemStatusMessage.version)
}

// optional string master = 4;
inline bool SystemStatusMessage::_internal_has_master() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SystemStatusMessage::has_master() const {
  return _internal_has_master();
}
inline void SystemStatusMessage::clear_master() {
  master_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SystemStatusMessage::master() const {
  // @@protoc_insertion_point(field_get:SystemStatusMessage.master)
  return _internal_master();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatusMessage::set_master(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 master_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemStatusMessage.master)
}
inline std::string* SystemStatusMessage::mutable_master() {
  // @@protoc_insertion_point(field_mutable:SystemStatusMessage.master)
  return _internal_mutable_master();
}
inline const std::string& SystemStatusMessage::_internal_master() const {
  return master_.Get();
}
inline void SystemStatusMessage::_internal_set_master(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  master_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SystemStatusMessage::_internal_mutable_master() {
  _has_bits_[0] |= 0x00000002u;
  return master_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SystemStatusMessage::release_master() {
  // @@protoc_insertion_point(field_release:SystemStatusMessage.master)
  if (!_internal_has_master()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return master_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SystemStatusMessage::set_allocated_master(std::string* master) {
  if (master != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  master_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), master,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SystemStatusMessage.master)
}

// optional string serial = 5;
inline bool SystemStatusMessage::_internal_has_serial() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SystemStatusMessage::has_serial() const {
  return _internal_has_serial();
}
inline void SystemStatusMessage::clear_serial() {
  serial_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SystemStatusMessage::serial() const {
  // @@protoc_insertion_point(field_get:SystemStatusMessage.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatusMessage::set_serial(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemStatusMessage.serial)
}
inline std::string* SystemStatusMessage::mutable_serial() {
  // @@protoc_insertion_point(field_mutable:SystemStatusMessage.serial)
  return _internal_mutable_serial();
}
inline const std::string& SystemStatusMessage::_internal_serial() const {
  return serial_.Get();
}
inline void SystemStatusMessage::_internal_set_serial(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SystemStatusMessage::_internal_mutable_serial() {
  _has_bits_[0] |= 0x00000004u;
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SystemStatusMessage::release_serial() {
  // @@protoc_insertion_point(field_release:SystemStatusMessage.serial)
  if (!_internal_has_serial()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return serial_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SystemStatusMessage::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SystemStatusMessage.serial)
}

// optional string serial_short = 6;
inline bool SystemStatusMessage::_internal_has_serial_short() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SystemStatusMessage::has_serial_short() const {
  return _internal_has_serial_short();
}
inline void SystemStatusMessage::clear_serial_short() {
  serial_short_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SystemStatusMessage::serial_short() const {
  // @@protoc_insertion_point(field_get:SystemStatusMessage.serial_short)
  return _internal_serial_short();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatusMessage::set_serial_short(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 serial_short_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemStatusMessage.serial_short)
}
inline std::string* SystemStatusMessage::mutable_serial_short() {
  // @@protoc_insertion_point(field_mutable:SystemStatusMessage.serial_short)
  return _internal_mutable_serial_short();
}
inline const std::string& SystemStatusMessage::_internal_serial_short() const {
  return serial_short_.Get();
}
inline void SystemStatusMessage::_internal_set_serial_short(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  serial_short_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SystemStatusMessage::_internal_mutable_serial_short() {
  _has_bits_[0] |= 0x00000008u;
  return serial_short_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SystemStatusMessage::release_serial_short() {
  // @@protoc_insertion_point(field_release:SystemStatusMessage.serial_short)
  if (!_internal_has_serial_short()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return serial_short_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SystemStatusMessage::set_allocated_serial_short(std::string* serial_short) {
  if (serial_short != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  serial_short_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_short,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SystemStatusMessage.serial_short)
}

// -------------------------------------------------------------------

// StatusPacket

// required string chassis_name = 1;
inline bool StatusPacket::_internal_has_chassis_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatusPacket::has_chassis_name() const {
  return _internal_has_chassis_name();
}
inline void StatusPacket::clear_chassis_name() {
  chassis_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StatusPacket::chassis_name() const {
  // @@protoc_insertion_point(field_get:StatusPacket.chassis_name)
  return _internal_chassis_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusPacket::set_chassis_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 chassis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StatusPacket.chassis_name)
}
inline std::string* StatusPacket::mutable_chassis_name() {
  // @@protoc_insertion_point(field_mutable:StatusPacket.chassis_name)
  return _internal_mutable_chassis_name();
}
inline const std::string& StatusPacket::_internal_chassis_name() const {
  return chassis_name_.Get();
}
inline void StatusPacket::_internal_set_chassis_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chassis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatusPacket::_internal_mutable_chassis_name() {
  _has_bits_[0] |= 0x00000001u;
  return chassis_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatusPacket::release_chassis_name() {
  // @@protoc_insertion_point(field_release:StatusPacket.chassis_name)
  if (!_internal_has_chassis_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return chassis_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatusPacket::set_allocated_chassis_name(std::string* chassis_name) {
  if (chassis_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chassis_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chassis_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:StatusPacket.chassis_name)
}

// required .StatusPacket.EnumStatusType type = 2;
inline bool StatusPacket::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StatusPacket::has_type() const {
  return _internal_has_type();
}
inline void StatusPacket::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::StatusPacket_EnumStatusType StatusPacket::_internal_type() const {
  return static_cast< ::StatusPacket_EnumStatusType >(type_);
}
inline ::StatusPacket_EnumStatusType StatusPacket::type() const {
  // @@protoc_insertion_point(field_get:StatusPacket.type)
  return _internal_type();
}
inline void StatusPacket::_internal_set_type(::StatusPacket_EnumStatusType value) {
  assert(::StatusPacket_EnumStatusType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
}
inline void StatusPacket::set_type(::StatusPacket_EnumStatusType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:StatusPacket.type)
}

// required uint32 num_sensors = 3;
inline bool StatusPacket::_internal_has_num_sensors() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StatusPacket::has_num_sensors() const {
  return _internal_has_num_sensors();
}
inline void StatusPacket::clear_num_sensors() {
  num_sensors_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StatusPacket::_internal_num_sensors() const {
  return num_sensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StatusPacket::num_sensors() const {
  // @@protoc_insertion_point(field_get:StatusPacket.num_sensors)
  return _internal_num_sensors();
}
inline void StatusPacket::_internal_set_num_sensors(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  num_sensors_ = value;
}
inline void StatusPacket::set_num_sensors(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_sensors(value);
  // @@protoc_insertion_point(field_set:StatusPacket.num_sensors)
}

// repeated .SensorStatus sensor_status = 4;
inline int StatusPacket::_internal_sensor_status_size() const {
  return sensor_status_.size();
}
inline int StatusPacket::sensor_status_size() const {
  return _internal_sensor_status_size();
}
inline void StatusPacket::clear_sensor_status() {
  sensor_status_.Clear();
}
inline ::SensorStatus* StatusPacket::mutable_sensor_status(int index) {
  // @@protoc_insertion_point(field_mutable:StatusPacket.sensor_status)
  return sensor_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorStatus >*
StatusPacket::mutable_sensor_status() {
  // @@protoc_insertion_point(field_mutable_list:StatusPacket.sensor_status)
  return &sensor_status_;
}
inline const ::SensorStatus& StatusPacket::_internal_sensor_status(int index) const {
  return sensor_status_.Get(index);
}
inline const ::SensorStatus& StatusPacket::sensor_status(int index) const {
  // @@protoc_insertion_point(field_get:StatusPacket.sensor_status)
  return _internal_sensor_status(index);
}
inline ::SensorStatus* StatusPacket::_internal_add_sensor_status() {
  return sensor_status_.Add();
}
inline ::SensorStatus* StatusPacket::add_sensor_status() {
  // @@protoc_insertion_point(field_add:StatusPacket.sensor_status)
  return _internal_add_sensor_status();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorStatus >&
StatusPacket::sensor_status() const {
  // @@protoc_insertion_point(field_list:StatusPacket.sensor_status)
  return sensor_status_;
}

// required string version = 5;
inline bool StatusPacket::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatusPacket::has_version() const {
  return _internal_has_version();
}
inline void StatusPacket::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StatusPacket::version() const {
  // @@protoc_insertion_point(field_get:StatusPacket.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusPacket::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StatusPacket.version)
}
inline std::string* StatusPacket::mutable_version() {
  // @@protoc_insertion_point(field_mutable:StatusPacket.version)
  return _internal_mutable_version();
}
inline const std::string& StatusPacket::_internal_version() const {
  return version_.Get();
}
inline void StatusPacket::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatusPacket::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000002u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatusPacket::release_version() {
  // @@protoc_insertion_point(field_release:StatusPacket.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatusPacket::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:StatusPacket.version)
}

// optional uint32 progress = 6;
inline bool StatusPacket::_internal_has_progress() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StatusPacket::has_progress() const {
  return _internal_has_progress();
}
inline void StatusPacket::clear_progress() {
  progress_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StatusPacket::_internal_progress() const {
  return progress_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StatusPacket::progress() const {
  // @@protoc_insertion_point(field_get:StatusPacket.progress)
  return _internal_progress();
}
inline void StatusPacket::_internal_set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  progress_ = value;
}
inline void StatusPacket::set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:StatusPacket.progress)
}

// optional string progress_msg = 7;
inline bool StatusPacket::_internal_has_progress_msg() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StatusPacket::has_progress_msg() const {
  return _internal_has_progress_msg();
}
inline void StatusPacket::clear_progress_msg() {
  progress_msg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StatusPacket::progress_msg() const {
  // @@protoc_insertion_point(field_get:StatusPacket.progress_msg)
  return _internal_progress_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusPacket::set_progress_msg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 progress_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StatusPacket.progress_msg)
}
inline std::string* StatusPacket::mutable_progress_msg() {
  // @@protoc_insertion_point(field_mutable:StatusPacket.progress_msg)
  return _internal_mutable_progress_msg();
}
inline const std::string& StatusPacket::_internal_progress_msg() const {
  return progress_msg_.Get();
}
inline void StatusPacket::_internal_set_progress_msg(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  progress_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatusPacket::_internal_mutable_progress_msg() {
  _has_bits_[0] |= 0x00000004u;
  return progress_msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatusPacket::release_progress_msg() {
  // @@protoc_insertion_point(field_release:StatusPacket.progress_msg)
  if (!_internal_has_progress_msg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return progress_msg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatusPacket::set_allocated_progress_msg(std::string* progress_msg) {
  if (progress_msg != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  progress_msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), progress_msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:StatusPacket.progress_msg)
}

// repeated .SensorConfig sensor_config = 8;
inline int StatusPacket::_internal_sensor_config_size() const {
  return sensor_config_.size();
}
inline int StatusPacket::sensor_config_size() const {
  return _internal_sensor_config_size();
}
inline void StatusPacket::clear_sensor_config() {
  sensor_config_.Clear();
}
inline ::SensorConfig* StatusPacket::mutable_sensor_config(int index) {
  // @@protoc_insertion_point(field_mutable:StatusPacket.sensor_config)
  return sensor_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorConfig >*
StatusPacket::mutable_sensor_config() {
  // @@protoc_insertion_point(field_mutable_list:StatusPacket.sensor_config)
  return &sensor_config_;
}
inline const ::SensorConfig& StatusPacket::_internal_sensor_config(int index) const {
  return sensor_config_.Get(index);
}
inline const ::SensorConfig& StatusPacket::sensor_config(int index) const {
  // @@protoc_insertion_point(field_get:StatusPacket.sensor_config)
  return _internal_sensor_config(index);
}
inline ::SensorConfig* StatusPacket::_internal_add_sensor_config() {
  return sensor_config_.Add();
}
inline ::SensorConfig* StatusPacket::add_sensor_config() {
  // @@protoc_insertion_point(field_add:StatusPacket.sensor_config)
  return _internal_add_sensor_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorConfig >&
StatusPacket::sensor_config() const {
  // @@protoc_insertion_point(field_list:StatusPacket.sensor_config)
  return sensor_config_;
}

// required .StatusPacket.EnumSystemStatus status = 9;
inline bool StatusPacket::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StatusPacket::has_status() const {
  return _internal_has_status();
}
inline void StatusPacket::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::StatusPacket_EnumSystemStatus StatusPacket::_internal_status() const {
  return static_cast< ::StatusPacket_EnumSystemStatus >(status_);
}
inline ::StatusPacket_EnumSystemStatus StatusPacket::status() const {
  // @@protoc_insertion_point(field_get:StatusPacket.status)
  return _internal_status();
}
inline void StatusPacket::_internal_set_status(::StatusPacket_EnumSystemStatus value) {
  assert(::StatusPacket_EnumSystemStatus_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  status_ = value;
}
inline void StatusPacket::set_status(::StatusPacket_EnumSystemStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:StatusPacket.status)
}

// repeated .SensorLed sensor_led = 10;
inline int StatusPacket::_internal_sensor_led_size() const {
  return sensor_led_.size();
}
inline int StatusPacket::sensor_led_size() const {
  return _internal_sensor_led_size();
}
inline void StatusPacket::clear_sensor_led() {
  sensor_led_.Clear();
}
inline ::SensorLed* StatusPacket::mutable_sensor_led(int index) {
  // @@protoc_insertion_point(field_mutable:StatusPacket.sensor_led)
  return sensor_led_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorLed >*
StatusPacket::mutable_sensor_led() {
  // @@protoc_insertion_point(field_mutable_list:StatusPacket.sensor_led)
  return &sensor_led_;
}
inline const ::SensorLed& StatusPacket::_internal_sensor_led(int index) const {
  return sensor_led_.Get(index);
}
inline const ::SensorLed& StatusPacket::sensor_led(int index) const {
  // @@protoc_insertion_point(field_get:StatusPacket.sensor_led)
  return _internal_sensor_led(index);
}
inline ::SensorLed* StatusPacket::_internal_add_sensor_led() {
  return sensor_led_.Add();
}
inline ::SensorLed* StatusPacket::add_sensor_led() {
  // @@protoc_insertion_point(field_add:StatusPacket.sensor_led)
  return _internal_add_sensor_led();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorLed >&
StatusPacket::sensor_led() const {
  // @@protoc_insertion_point(field_list:StatusPacket.sensor_led)
  return sensor_led_;
}

// repeated .SensorState sensor_state = 11;
inline int StatusPacket::_internal_sensor_state_size() const {
  return sensor_state_.size();
}
inline int StatusPacket::sensor_state_size() const {
  return _internal_sensor_state_size();
}
inline void StatusPacket::clear_sensor_state() {
  sensor_state_.Clear();
}
inline ::SensorState* StatusPacket::mutable_sensor_state(int index) {
  // @@protoc_insertion_point(field_mutable:StatusPacket.sensor_state)
  return sensor_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorState >*
StatusPacket::mutable_sensor_state() {
  // @@protoc_insertion_point(field_mutable_list:StatusPacket.sensor_state)
  return &sensor_state_;
}
inline const ::SensorState& StatusPacket::_internal_sensor_state(int index) const {
  return sensor_state_.Get(index);
}
inline const ::SensorState& StatusPacket::sensor_state(int index) const {
  // @@protoc_insertion_point(field_get:StatusPacket.sensor_state)
  return _internal_sensor_state(index);
}
inline ::SensorState* StatusPacket::_internal_add_sensor_state() {
  return sensor_state_.Add();
}
inline ::SensorState* StatusPacket::add_sensor_state() {
  // @@protoc_insertion_point(field_add:StatusPacket.sensor_state)
  return _internal_add_sensor_state();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorState >&
StatusPacket::sensor_state() const {
  // @@protoc_insertion_point(field_list:StatusPacket.sensor_state)
  return sensor_state_;
}

// repeated .SensorField sensor_field = 12;
inline int StatusPacket::_internal_sensor_field_size() const {
  return sensor_field_.size();
}
inline int StatusPacket::sensor_field_size() const {
  return _internal_sensor_field_size();
}
inline void StatusPacket::clear_sensor_field() {
  sensor_field_.Clear();
}
inline ::SensorField* StatusPacket::mutable_sensor_field(int index) {
  // @@protoc_insertion_point(field_mutable:StatusPacket.sensor_field)
  return sensor_field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorField >*
StatusPacket::mutable_sensor_field() {
  // @@protoc_insertion_point(field_mutable_list:StatusPacket.sensor_field)
  return &sensor_field_;
}
inline const ::SensorField& StatusPacket::_internal_sensor_field(int index) const {
  return sensor_field_.Get(index);
}
inline const ::SensorField& StatusPacket::sensor_field(int index) const {
  // @@protoc_insertion_point(field_get:StatusPacket.sensor_field)
  return _internal_sensor_field(index);
}
inline ::SensorField* StatusPacket::_internal_add_sensor_field() {
  return sensor_field_.Add();
}
inline ::SensorField* StatusPacket::add_sensor_field() {
  // @@protoc_insertion_point(field_add:StatusPacket.sensor_field)
  return _internal_add_sensor_field();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorField >&
StatusPacket::sensor_field() const {
  // @@protoc_insertion_point(field_list:StatusPacket.sensor_field)
  return sensor_field_;
}

// optional .ChassisStatus chassis_status = 13;
inline bool StatusPacket::_internal_has_chassis_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || chassis_status_ != nullptr);
  return value;
}
inline bool StatusPacket::has_chassis_status() const {
  return _internal_has_chassis_status();
}
inline void StatusPacket::clear_chassis_status() {
  if (chassis_status_ != nullptr) chassis_status_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ChassisStatus& StatusPacket::_internal_chassis_status() const {
  const ::ChassisStatus* p = chassis_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChassisStatus&>(
      ::_ChassisStatus_default_instance_);
}
inline const ::ChassisStatus& StatusPacket::chassis_status() const {
  // @@protoc_insertion_point(field_get:StatusPacket.chassis_status)
  return _internal_chassis_status();
}
inline void StatusPacket::unsafe_arena_set_allocated_chassis_status(
    ::ChassisStatus* chassis_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chassis_status_);
  }
  chassis_status_ = chassis_status;
  if (chassis_status) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StatusPacket.chassis_status)
}
inline ::ChassisStatus* StatusPacket::release_chassis_status() {
  _has_bits_[0] &= ~0x00000008u;
  ::ChassisStatus* temp = chassis_status_;
  chassis_status_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ChassisStatus* StatusPacket::unsafe_arena_release_chassis_status() {
  // @@protoc_insertion_point(field_release:StatusPacket.chassis_status)
  _has_bits_[0] &= ~0x00000008u;
  ::ChassisStatus* temp = chassis_status_;
  chassis_status_ = nullptr;
  return temp;
}
inline ::ChassisStatus* StatusPacket::_internal_mutable_chassis_status() {
  _has_bits_[0] |= 0x00000008u;
  if (chassis_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChassisStatus>(GetArenaForAllocation());
    chassis_status_ = p;
  }
  return chassis_status_;
}
inline ::ChassisStatus* StatusPacket::mutable_chassis_status() {
  // @@protoc_insertion_point(field_mutable:StatusPacket.chassis_status)
  return _internal_mutable_chassis_status();
}
inline void StatusPacket::set_allocated_chassis_status(::ChassisStatus* chassis_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chassis_status_;
  }
  if (chassis_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ChassisStatus>::GetOwningArena(chassis_status);
    if (message_arena != submessage_arena) {
      chassis_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chassis_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  chassis_status_ = chassis_status;
  // @@protoc_insertion_point(field_set_allocated:StatusPacket.chassis_status)
}

// optional .SystemStatusMessage system_status = 14;
inline bool StatusPacket::_internal_has_system_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || system_status_ != nullptr);
  return value;
}
inline bool StatusPacket::has_system_status() const {
  return _internal_has_system_status();
}
inline void StatusPacket::clear_system_status() {
  if (system_status_ != nullptr) system_status_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::SystemStatusMessage& StatusPacket::_internal_system_status() const {
  const ::SystemStatusMessage* p = system_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::SystemStatusMessage&>(
      ::_SystemStatusMessage_default_instance_);
}
inline const ::SystemStatusMessage& StatusPacket::system_status() const {
  // @@protoc_insertion_point(field_get:StatusPacket.system_status)
  return _internal_system_status();
}
inline void StatusPacket::unsafe_arena_set_allocated_system_status(
    ::SystemStatusMessage* system_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_status_);
  }
  system_status_ = system_status;
  if (system_status) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StatusPacket.system_status)
}
inline ::SystemStatusMessage* StatusPacket::release_system_status() {
  _has_bits_[0] &= ~0x00000010u;
  ::SystemStatusMessage* temp = system_status_;
  system_status_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::SystemStatusMessage* StatusPacket::unsafe_arena_release_system_status() {
  // @@protoc_insertion_point(field_release:StatusPacket.system_status)
  _has_bits_[0] &= ~0x00000010u;
  ::SystemStatusMessage* temp = system_status_;
  system_status_ = nullptr;
  return temp;
}
inline ::SystemStatusMessage* StatusPacket::_internal_mutable_system_status() {
  _has_bits_[0] |= 0x00000010u;
  if (system_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::SystemStatusMessage>(GetArenaForAllocation());
    system_status_ = p;
  }
  return system_status_;
}
inline ::SystemStatusMessage* StatusPacket::mutable_system_status() {
  // @@protoc_insertion_point(field_mutable:StatusPacket.system_status)
  return _internal_mutable_system_status();
}
inline void StatusPacket::set_allocated_system_status(::SystemStatusMessage* system_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete system_status_;
  }
  if (system_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SystemStatusMessage>::GetOwningArena(system_status);
    if (message_arena != submessage_arena) {
      system_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  system_status_ = system_status;
  // @@protoc_insertion_point(field_set_allocated:StatusPacket.system_status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::LogicMessage_EnumLogicType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LogicMessage_EnumLogicType>() {
  return ::LogicMessage_EnumLogicType_descriptor();
}
template <> struct is_proto_enum< ::WaveMessage_WaveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WaveMessage_WaveType>() {
  return ::WaveMessage_WaveType_descriptor();
}
template <> struct is_proto_enum< ::CmdPacket_EnumCmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CmdPacket_EnumCmdType>() {
  return ::CmdPacket_EnumCmdType_descriptor();
}
template <> struct is_proto_enum< ::SensorState_EnumStateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorState_EnumStateType>() {
  return ::SensorState_EnumStateType_descriptor();
}
template <> struct is_proto_enum< ::StatusPacket_EnumStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StatusPacket_EnumStatusType>() {
  return ::StatusPacket_EnumStatusType_descriptor();
}
template <> struct is_proto_enum< ::StatusPacket_EnumSystemStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StatusPacket_EnumSystemStatus>() {
  return ::StatusPacket_EnumSystemStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_net_2dprotocol_2eproto
