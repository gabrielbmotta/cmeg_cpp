// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net-protocol.proto

#include "net-protocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr DataFrame::DataFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_(0)
  , datatype_(0)
  , val_(0){}
struct DataFrameDefaultTypeInternal {
  constexpr DataFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DataFrameDefaultTypeInternal() {}
  union {
    DataFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DataFrameDefaultTypeInternal _DataFrame_default_instance_;
constexpr DataPacket::DataPacket(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_()
  , chassis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , timestamp_(0u)
  , num_sensors_(0){}
struct DataPacketDefaultTypeInternal {
  constexpr DataPacketDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DataPacketDefaultTypeInternal() {}
  union {
    DataPacket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DataPacketDefaultTypeInternal _DataPacket_default_instance_;
constexpr RawCommand::RawCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : all_sensors_(false)
  , sensor_num_(0u)
  , register_address_(0u)
  , data_(0u){}
struct RawCommandDefaultTypeInternal {
  constexpr RawCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RawCommandDefaultTypeInternal() {}
  union {
    RawCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RawCommandDefaultTypeInternal _RawCommand_default_instance_;
constexpr DevModeValidation::DevModeValidation(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , valid_(false)
  , enable_(false){}
struct DevModeValidationDefaultTypeInternal {
  constexpr DevModeValidationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DevModeValidationDefaultTypeInternal() {}
  union {
    DevModeValidation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DevModeValidationDefaultTypeInternal _DevModeValidation_default_instance_;
constexpr ConfigMessage::ConfigMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_id_(0u)
  , datatype_(0u)
  , freq_(0u){}
struct ConfigMessageDefaultTypeInternal {
  constexpr ConfigMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConfigMessageDefaultTypeInternal() {}
  union {
    ConfigMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConfigMessageDefaultTypeInternal _ConfigMessage_default_instance_;
constexpr LogicMessage::LogicMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_list_()
  , sensor_id_(0u)
  , type_(1)
{}
struct LogicMessageDefaultTypeInternal {
  constexpr LogicMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LogicMessageDefaultTypeInternal() {}
  union {
    LogicMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LogicMessageDefaultTypeInternal _LogicMessage_default_instance_;
constexpr LogicInterruptMessage::LogicInterruptMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_list_()
  , type_(0u){}
struct LogicInterruptMessageDefaultTypeInternal {
  constexpr LogicInterruptMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LogicInterruptMessageDefaultTypeInternal() {}
  union {
    LogicInterruptMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LogicInterruptMessageDefaultTypeInternal _LogicInterruptMessage_default_instance_;
constexpr WaveMessage::WaveMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_id_(0u)
  , freq_(0)
  , amp_(0)
  , type_(0u){}
struct WaveMessageDefaultTypeInternal {
  constexpr WaveMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WaveMessageDefaultTypeInternal() {}
  union {
    WaveMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WaveMessageDefaultTypeInternal _WaveMessage_default_instance_;
constexpr CmdPacket::CmdPacket(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_list_()
  , logic_req_()
  , wave_req_()
  , logic_interrupt_req_()
  , uri_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , raw_cmd_(nullptr)
  , dev_mode_(nullptr)
  , sensor_id_(0u)
  , datatype_(0u)
  , freq_(0u)
  , chassis_ident_(false)
  , closed_loop_(false)
  , num_sync_chassis_(0u)
  , cmd_(2)
{}
struct CmdPacketDefaultTypeInternal {
  constexpr CmdPacketDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CmdPacketDefaultTypeInternal() {}
  union {
    CmdPacket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CmdPacketDefaultTypeInternal _CmdPacket_default_instance_;
constexpr SensorStatus::SensorStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_card_serial_num_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sensor_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sensor_serial_num_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sensor_id_(0u)
  , sensor_connected_(false){}
struct SensorStatusDefaultTypeInternal {
  constexpr SensorStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SensorStatusDefaultTypeInternal() {}
  union {
    SensorStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SensorStatusDefaultTypeInternal _SensorStatus_default_instance_;
constexpr SensorState::SensorState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_id_(0u)
  , state_(0)

  , error_flags_(0u){}
struct SensorStateDefaultTypeInternal {
  constexpr SensorStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SensorStateDefaultTypeInternal() {}
  union {
    SensorState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SensorStateDefaultTypeInternal _SensorState_default_instance_;
constexpr SensorConfig::SensorConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_(0u)
  , datatype_(0u)
  , freq_(0u)
  , calibration_(0){}
struct SensorConfigDefaultTypeInternal {
  constexpr SensorConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SensorConfigDefaultTypeInternal() {}
  union {
    SensorConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SensorConfigDefaultTypeInternal _SensorConfig_default_instance_;
constexpr SensorLed::SensorLed(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_id_(0u)
  , blink_state_(0u)
  , color_(0u){}
struct SensorLedDefaultTypeInternal {
  constexpr SensorLedDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SensorLedDefaultTypeInternal() {}
  union {
    SensorLed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SensorLedDefaultTypeInternal _SensorLed_default_instance_;
constexpr SensorField::SensorField(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_id_(0u)
  , field_x_(0)
  , field_y_(0)
  , field_z_(0){}
struct SensorFieldDefaultTypeInternal {
  constexpr SensorFieldDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SensorFieldDefaultTypeInternal() {}
  union {
    SensorField _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SensorFieldDefaultTypeInternal _SensorField_default_instance_;
constexpr ChassisStatus::ChassisStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : closed_loop_(false){}
struct ChassisStatusDefaultTypeInternal {
  constexpr ChassisStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ChassisStatusDefaultTypeInternal() {}
  union {
    ChassisStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ChassisStatusDefaultTypeInternal _ChassisStatus_default_instance_;
constexpr SystemStatusMessage::SystemStatusMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , master_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serial_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serial_short_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , num_(0u)
  , total_(0u){}
struct SystemStatusMessageDefaultTypeInternal {
  constexpr SystemStatusMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SystemStatusMessageDefaultTypeInternal() {}
  union {
    SystemStatusMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SystemStatusMessageDefaultTypeInternal _SystemStatusMessage_default_instance_;
constexpr StatusPacket::StatusPacket(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_status_()
  , sensor_config_()
  , sensor_led_()
  , sensor_state_()
  , sensor_field_()
  , chassis_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , progress_msg_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , chassis_status_(nullptr)
  , system_status_(nullptr)
  , type_(0)

  , num_sensors_(0u)
  , progress_(0u)
  , status_(0)
{}
struct StatusPacketDefaultTypeInternal {
  constexpr StatusPacketDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatusPacketDefaultTypeInternal() {}
  union {
    StatusPacket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatusPacketDefaultTypeInternal _StatusPacket_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_net_2dprotocol_2eproto[17];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_net_2dprotocol_2eproto[6];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_net_2dprotocol_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_net_2dprotocol_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::DataFrame, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::DataFrame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::DataFrame, sensor_),
  PROTOBUF_FIELD_OFFSET(::DataFrame, datatype_),
  PROTOBUF_FIELD_OFFSET(::DataFrame, val_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::DataPacket, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::DataPacket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::DataPacket, timestamp_),
  PROTOBUF_FIELD_OFFSET(::DataPacket, chassis_name_),
  PROTOBUF_FIELD_OFFSET(::DataPacket, num_sensors_),
  PROTOBUF_FIELD_OFFSET(::DataPacket, data_),
  1,
  0,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::RawCommand, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RawCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::RawCommand, all_sensors_),
  PROTOBUF_FIELD_OFFSET(::RawCommand, sensor_num_),
  PROTOBUF_FIELD_OFFSET(::RawCommand, register_address_),
  PROTOBUF_FIELD_OFFSET(::RawCommand, data_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::DevModeValidation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::DevModeValidation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::DevModeValidation, password_),
  PROTOBUF_FIELD_OFFSET(::DevModeValidation, valid_),
  PROTOBUF_FIELD_OFFSET(::DevModeValidation, enable_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ConfigMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ConfigMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ConfigMessage, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::ConfigMessage, datatype_),
  PROTOBUF_FIELD_OFFSET(::ConfigMessage, freq_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::LogicMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::LogicMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::LogicMessage, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::LogicMessage, type_),
  PROTOBUF_FIELD_OFFSET(::LogicMessage, sensor_list_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::LogicInterruptMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::LogicInterruptMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::LogicInterruptMessage, type_),
  PROTOBUF_FIELD_OFFSET(::LogicInterruptMessage, sensor_list_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::WaveMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::WaveMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::WaveMessage, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::WaveMessage, freq_),
  PROTOBUF_FIELD_OFFSET(::WaveMessage, amp_),
  PROTOBUF_FIELD_OFFSET(::WaveMessage, type_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CmdPacket, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CmdPacket, cmd_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, datatype_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, freq_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, raw_cmd_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, uri_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, config_list_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, dev_mode_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, logic_req_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, wave_req_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, chassis_ident_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, closed_loop_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, logic_interrupt_req_),
  PROTOBUF_FIELD_OFFSET(::CmdPacket, num_sync_chassis_),
  9,
  3,
  4,
  5,
  1,
  0,
  ~0u,
  2,
  ~0u,
  ~0u,
  6,
  7,
  ~0u,
  8,
  PROTOBUF_FIELD_OFFSET(::SensorStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SensorStatus, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::SensorStatus, sensor_card_serial_num_),
  PROTOBUF_FIELD_OFFSET(::SensorStatus, sensor_version_),
  PROTOBUF_FIELD_OFFSET(::SensorStatus, sensor_connected_),
  PROTOBUF_FIELD_OFFSET(::SensorStatus, sensor_serial_num_),
  3,
  0,
  1,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::SensorState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SensorState, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::SensorState, state_),
  PROTOBUF_FIELD_OFFSET(::SensorState, error_flags_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::SensorConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SensorConfig, sensor_),
  PROTOBUF_FIELD_OFFSET(::SensorConfig, datatype_),
  PROTOBUF_FIELD_OFFSET(::SensorConfig, freq_),
  PROTOBUF_FIELD_OFFSET(::SensorConfig, calibration_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::SensorLed, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorLed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SensorLed, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::SensorLed, blink_state_),
  PROTOBUF_FIELD_OFFSET(::SensorLed, color_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::SensorField, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorField, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SensorField, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::SensorField, field_x_),
  PROTOBUF_FIELD_OFFSET(::SensorField, field_y_),
  PROTOBUF_FIELD_OFFSET(::SensorField, field_z_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::ChassisStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ChassisStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ChassisStatus, closed_loop_),
  0,
  PROTOBUF_FIELD_OFFSET(::SystemStatusMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SystemStatusMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SystemStatusMessage, num_),
  PROTOBUF_FIELD_OFFSET(::SystemStatusMessage, total_),
  PROTOBUF_FIELD_OFFSET(::SystemStatusMessage, version_),
  PROTOBUF_FIELD_OFFSET(::SystemStatusMessage, master_),
  PROTOBUF_FIELD_OFFSET(::SystemStatusMessage, serial_),
  PROTOBUF_FIELD_OFFSET(::SystemStatusMessage, serial_short_),
  4,
  5,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::StatusPacket, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::StatusPacket, chassis_name_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, type_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, num_sensors_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, sensor_status_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, version_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, progress_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, progress_msg_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, sensor_config_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, status_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, sensor_led_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, sensor_state_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, sensor_field_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, chassis_status_),
  PROTOBUF_FIELD_OFFSET(::StatusPacket, system_status_),
  0,
  5,
  6,
  ~0u,
  1,
  7,
  2,
  ~0u,
  8,
  ~0u,
  ~0u,
  ~0u,
  3,
  4,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::DataFrame)},
  { 11, 20, sizeof(::DataPacket)},
  { 24, 33, sizeof(::RawCommand)},
  { 37, 45, sizeof(::DevModeValidation)},
  { 48, 56, sizeof(::ConfigMessage)},
  { 59, 67, sizeof(::LogicMessage)},
  { 70, 77, sizeof(::LogicInterruptMessage)},
  { 79, 88, sizeof(::WaveMessage)},
  { 92, 111, sizeof(::CmdPacket)},
  { 125, 135, sizeof(::SensorStatus)},
  { 140, 148, sizeof(::SensorState)},
  { 151, 160, sizeof(::SensorConfig)},
  { 164, 172, sizeof(::SensorLed)},
  { 175, 184, sizeof(::SensorField)},
  { 188, 194, sizeof(::ChassisStatus)},
  { 195, 206, sizeof(::SystemStatusMessage)},
  { 212, 231, sizeof(::StatusPacket)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_DataFrame_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_DataPacket_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_RawCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_DevModeValidation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ConfigMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_LogicMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_LogicInterruptMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_WaveMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CmdPacket_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SensorStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SensorState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SensorConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SensorLed_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SensorField_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ChassisStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SystemStatusMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_StatusPacket_default_instance_),
};

const char descriptor_table_protodef_net_2dprotocol_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022net-protocol.proto\":\n\tDataFrame\022\016\n\006sen"
  "sor\030\001 \002(\005\022\020\n\010datatype\030\002 \002(\005\022\013\n\003val\030\003 \002(\005"
  "\"d\n\nDataPacket\022\021\n\ttimestamp\030\001 \002(\r\022\024\n\014cha"
  "ssis_name\030\002 \002(\t\022\023\n\013num_sensors\030\003 \002(\005\022\030\n\004"
  "data\030\004 \003(\0132\n.DataFrame\"]\n\nRawCommand\022\023\n\013"
  "all_sensors\030\001 \002(\010\022\022\n\nsensor_num\030\002 \002(\r\022\030\n"
  "\020register_address\030\003 \002(\r\022\014\n\004data\030\004 \002(\r\"D\n"
  "\021DevModeValidation\022\020\n\010password\030\001 \001(\t\022\r\n\005"
  "valid\030\002 \001(\010\022\016\n\006enable\030\003 \001(\010\"B\n\rConfigMes"
  "sage\022\021\n\tsensor_id\030\001 \001(\r\022\020\n\010datatype\030\002 \001("
  "\r\022\014\n\004freq\030\003 \001(\r\"\255\002\n\014LogicMessage\022\021\n\tsens"
  "or_id\030\001 \001(\r\022)\n\004type\030\002 \001(\0162\033.LogicMessage"
  ".EnumLogicType\022\023\n\013sensor_list\030\003 \003(\r\"\311\001\n\r"
  "EnumLogicType\022\030\n\024LOGIC_SENSOR_RESTART\020\001\022"
  "\034\n\030LOGIC_SENSOR_COARSE_ZERO\020\002\022\024\n\020LOGIC_S"
  "ENSOR_OFF\020\003\022\025\n\021LOGIC_SENSOR_IDLE\020\004\022\032\n\026LO"
  "GIC_SENSOR_FINE_ZERO\020\005\022\032\n\026LOGIC_SENSOR_S"
  "TASIS_ON\020 \022\033\n\027LOGIC_SENSOR_STASIS_OFF\020!\""
  ":\n\025LogicInterruptMessage\022\014\n\004type\030\001 \001(\r\022\023"
  "\n\013sensor_list\030\002 \003(\r\"\201\001\n\013WaveMessage\022\021\n\ts"
  "ensor_id\030\001 \001(\r\022\014\n\004freq\030\002 \001(\002\022\013\n\003amp\030\003 \001("
  "\002\022\014\n\004type\030\004 \001(\r\"6\n\010WaveType\022\014\n\010WAVE_OFF\020"
  "\000\022\r\n\tWAVE_RAMP\020\001\022\r\n\tWAVE_SINE\020\002\"\350\006\n\tCmdP"
  "acket\022#\n\003cmd\030\001 \002(\0162\026.CmdPacket.EnumCmdTy"
  "pe\022\021\n\tsensor_id\030\002 \001(\r\022\020\n\010datatype\030\003 \001(\r\022"
  "\014\n\004freq\030\004 \001(\r\022\034\n\007raw_cmd\030\005 \001(\0132\013.RawComm"
  "and\022\013\n\003uri\030\006 \001(\t\022#\n\013config_list\030\007 \003(\0132\016."
  "ConfigMessage\022$\n\010dev_mode\030\010 \001(\0132\022.DevMod"
  "eValidation\022 \n\tlogic_req\030\t \003(\0132\r.LogicMe"
  "ssage\022\036\n\010wave_req\030\n \003(\0132\014.WaveMessage\022\025\n"
  "\rchassis_ident\030\013 \001(\010\022\023\n\013closed_loop\030\014 \001("
  "\010\0223\n\023logic_interrupt_req\030\r \003(\0132\026.LogicIn"
  "terruptMessage\022\030\n\020num_sync_chassis\030\016 \001(\r"
  "\"\317\003\n\013EnumCmdType\022\016\n\nSTATUS_REQ\020\002\022\017\n\013CONF"
  "IG_DATA\020\003\022\013\n\007RAW_CMD\020\004\022\020\n\014RAW_CMD_RESP\020\005"
  "\022\n\n\006DL_URI\020\006\022\016\n\nRESET_FPGA\020\007\022\n\n\006UPDATE\020\010"
  "\022\021\n\rUPDATE_COMMIT\020\t\022\025\n\021SENSOR_STATUS_REQ"
  "\020\n\022\025\n\021SENSOR_CONFIG_REQ\020\013\022\021\n\rFLASH_CHASS"
  "IS\020\014\022\021\n\rFLASH_SENSORS\020\r\022\n\n\006REBOOT\020\016\022\010\n\004S"
  "YNC\020\017\022\025\n\021ONE_TIME_READ_REQ\020\020\022\017\n\013CONFIG_L"
  "IST\020\021\022\020\n\014DEV_MODE_REQ\020\022\022\r\n\tLOGIC_REQ\020\023\022\014"
  "\n\010WAVE_REQ\020\024\022\r\n\tIDENT_REQ\020\025\022\023\n\017CLOSED_LO"
  "OP_REQ\020\026\022\025\n\021SYSTEM_STATUS_REQ\020\027\022\027\n\023LOGIC"
  "_INTERRUPT_REQ\020\030\022\020\n\014SYNC_CMD_REQ\020\031\022\036\n\032CO"
  "MPLETE_SYSTEM_STATUS_REQ\020\032\"\216\001\n\014SensorSta"
  "tus\022\021\n\tsensor_id\030\001 \002(\r\022\036\n\026sensor_card_se"
  "rial_num\030\002 \001(\t\022\026\n\016sensor_version\030\003 \001(\t\022\030"
  "\n\020sensor_connected\030\004 \001(\010\022\031\n\021sensor_seria"
  "l_num\030\005 \001(\t\"\240\002\n\013SensorState\022\021\n\tsensor_id"
  "\030\001 \001(\r\022)\n\005state\030\002 \001(\0162\032.SensorState.Enum"
  "StateType\022\023\n\013error_flags\030\003 \001(\r\"\275\001\n\rEnumS"
  "tateType\022\007\n\003OFF\020\000\022\010\n\004IDLE\020\001\022\t\n\005ERROR\020\002\022\016"
  "\n\nSOFT_ERROR\020\003\022\t\n\005READY\020\004\022\013\n\007RESTART\020\n\022\024"
  "\n\020RESTART_COMPLETE\020\013\022\017\n\013COARSE_ZERO\020\014\022\030\n"
  "\024COARSE_ZERO_COMPLETE\020\r\022\r\n\tFINE_ZERO\020\016\022\026"
  "\n\022FINE_ZERO_COMPLETE\020\017\"S\n\014SensorConfig\022\016"
  "\n\006sensor\030\001 \002(\r\022\020\n\010datatype\030\002 \002(\r\022\014\n\004freq"
  "\030\003 \002(\r\022\023\n\013calibration\030\004 \001(\002\"B\n\tSensorLed"
  "\022\021\n\tsensor_id\030\001 \001(\r\022\023\n\013blink_state\030\002 \001(\r"
  "\022\r\n\005color\030\003 \001(\r\"S\n\013SensorField\022\021\n\tsensor"
  "_id\030\001 \001(\r\022\017\n\007field_x\030\002 \001(\002\022\017\n\007field_y\030\003 "
  "\001(\002\022\017\n\007field_z\030\004 \001(\002\"$\n\rChassisStatus\022\023\n"
  "\013closed_loop\030\001 \001(\010\"x\n\023SystemStatusMessag"
  "e\022\013\n\003num\030\001 \001(\r\022\r\n\005total\030\002 \001(\r\022\017\n\007version"
  "\030\003 \001(\t\022\016\n\006master\030\004 \001(\t\022\016\n\006serial\030\005 \001(\t\022\024"
  "\n\014serial_short\030\006 \001(\t\"\237\006\n\014StatusPacket\022\024\n"
  "\014chassis_name\030\001 \002(\t\022*\n\004type\030\002 \002(\0162\034.Stat"
  "usPacket.EnumStatusType\022\023\n\013num_sensors\030\003"
  " \002(\r\022$\n\rsensor_status\030\004 \003(\0132\r.SensorStat"
  "us\022\017\n\007version\030\005 \002(\t\022\020\n\010progress\030\006 \001(\r\022\024\n"
  "\014progress_msg\030\007 \001(\t\022$\n\rsensor_config\030\010 \003"
  "(\0132\r.SensorConfig\022.\n\006status\030\t \002(\0162\036.Stat"
  "usPacket.EnumSystemStatus\022\036\n\nsensor_led\030"
  "\n \003(\0132\n.SensorLed\022\"\n\014sensor_state\030\013 \003(\0132"
  "\014.SensorState\022\"\n\014sensor_field\030\014 \003(\0132\014.Se"
  "nsorField\022&\n\016chassis_status\030\r \001(\0132\016.Chas"
  "sisStatus\022+\n\rsystem_status\030\016 \001(\0132\024.Syste"
  "mStatusMessage\"\263\001\n\016EnumStatusType\022\n\n\006STA"
  "TUS\020\000\022\014\n\010PROGRESS\020\001\022\021\n\rSENSOR_STATUS\020\002\022\021"
  "\n\rSENSOR_CONFIG\020\003\022\016\n\nSENSOR_LED\020\004\022\020\n\014SEN"
  "SOR_STATE\020\005\022\020\n\014SENSOR_FIELD\020\006\022\021\n\rSYSTEM_"
  "STATUS\020\007\022\032\n\026COMPLETE_SYSTEM_STATUS\020\010\"\217\001\n"
  "\020EnumSystemStatus\022\013\n\007STARTUP\020\000\022\014\n\010FLASHI"
  "NG\020\001\022\013\n\007RUNNING\020\002\022\026\n\022MENDER_UPDATE_FAIL\020"
  "\003\022\024\n\020FPGA_UPDATE_FAIL\020\004\022\022\n\016PENDING_COMMI"
  "T\020\005\022\021\n\rSTARTUP_ERROR\020\006"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_net_2dprotocol_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_net_2dprotocol_2eproto = {
  false, false, 3422, descriptor_table_protodef_net_2dprotocol_2eproto, "net-protocol.proto", 
  &descriptor_table_net_2dprotocol_2eproto_once, nullptr, 0, 17,
  schemas, file_default_instances, TableStruct_net_2dprotocol_2eproto::offsets,
  file_level_metadata_net_2dprotocol_2eproto, file_level_enum_descriptors_net_2dprotocol_2eproto, file_level_service_descriptors_net_2dprotocol_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_net_2dprotocol_2eproto_getter() {
  return &descriptor_table_net_2dprotocol_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_net_2dprotocol_2eproto(&descriptor_table_net_2dprotocol_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogicMessage_EnumLogicType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_net_2dprotocol_2eproto);
  return file_level_enum_descriptors_net_2dprotocol_2eproto[0];
}
bool LogicMessage_EnumLogicType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 32:
    case 33:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LogicMessage_EnumLogicType LogicMessage::LOGIC_SENSOR_RESTART;
constexpr LogicMessage_EnumLogicType LogicMessage::LOGIC_SENSOR_COARSE_ZERO;
constexpr LogicMessage_EnumLogicType LogicMessage::LOGIC_SENSOR_OFF;
constexpr LogicMessage_EnumLogicType LogicMessage::LOGIC_SENSOR_IDLE;
constexpr LogicMessage_EnumLogicType LogicMessage::LOGIC_SENSOR_FINE_ZERO;
constexpr LogicMessage_EnumLogicType LogicMessage::LOGIC_SENSOR_STASIS_ON;
constexpr LogicMessage_EnumLogicType LogicMessage::LOGIC_SENSOR_STASIS_OFF;
constexpr LogicMessage_EnumLogicType LogicMessage::EnumLogicType_MIN;
constexpr LogicMessage_EnumLogicType LogicMessage::EnumLogicType_MAX;
constexpr int LogicMessage::EnumLogicType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WaveMessage_WaveType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_net_2dprotocol_2eproto);
  return file_level_enum_descriptors_net_2dprotocol_2eproto[1];
}
bool WaveMessage_WaveType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr WaveMessage_WaveType WaveMessage::WAVE_OFF;
constexpr WaveMessage_WaveType WaveMessage::WAVE_RAMP;
constexpr WaveMessage_WaveType WaveMessage::WAVE_SINE;
constexpr WaveMessage_WaveType WaveMessage::WaveType_MIN;
constexpr WaveMessage_WaveType WaveMessage::WaveType_MAX;
constexpr int WaveMessage::WaveType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CmdPacket_EnumCmdType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_net_2dprotocol_2eproto);
  return file_level_enum_descriptors_net_2dprotocol_2eproto[2];
}
bool CmdPacket_EnumCmdType_IsValid(int value) {
  switch (value) {
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr CmdPacket_EnumCmdType CmdPacket::STATUS_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::CONFIG_DATA;
constexpr CmdPacket_EnumCmdType CmdPacket::RAW_CMD;
constexpr CmdPacket_EnumCmdType CmdPacket::RAW_CMD_RESP;
constexpr CmdPacket_EnumCmdType CmdPacket::DL_URI;
constexpr CmdPacket_EnumCmdType CmdPacket::RESET_FPGA;
constexpr CmdPacket_EnumCmdType CmdPacket::UPDATE;
constexpr CmdPacket_EnumCmdType CmdPacket::UPDATE_COMMIT;
constexpr CmdPacket_EnumCmdType CmdPacket::SENSOR_STATUS_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::SENSOR_CONFIG_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::FLASH_CHASSIS;
constexpr CmdPacket_EnumCmdType CmdPacket::FLASH_SENSORS;
constexpr CmdPacket_EnumCmdType CmdPacket::REBOOT;
constexpr CmdPacket_EnumCmdType CmdPacket::SYNC;
constexpr CmdPacket_EnumCmdType CmdPacket::ONE_TIME_READ_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::CONFIG_LIST;
constexpr CmdPacket_EnumCmdType CmdPacket::DEV_MODE_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::LOGIC_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::WAVE_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::IDENT_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::CLOSED_LOOP_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::SYSTEM_STATUS_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::LOGIC_INTERRUPT_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::SYNC_CMD_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::COMPLETE_SYSTEM_STATUS_REQ;
constexpr CmdPacket_EnumCmdType CmdPacket::EnumCmdType_MIN;
constexpr CmdPacket_EnumCmdType CmdPacket::EnumCmdType_MAX;
constexpr int CmdPacket::EnumCmdType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorState_EnumStateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_net_2dprotocol_2eproto);
  return file_level_enum_descriptors_net_2dprotocol_2eproto[3];
}
bool SensorState_EnumStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SensorState_EnumStateType SensorState::OFF;
constexpr SensorState_EnumStateType SensorState::IDLE;
constexpr SensorState_EnumStateType SensorState::ERROR;
constexpr SensorState_EnumStateType SensorState::SOFT_ERROR;
constexpr SensorState_EnumStateType SensorState::READY;
constexpr SensorState_EnumStateType SensorState::RESTART;
constexpr SensorState_EnumStateType SensorState::RESTART_COMPLETE;
constexpr SensorState_EnumStateType SensorState::COARSE_ZERO;
constexpr SensorState_EnumStateType SensorState::COARSE_ZERO_COMPLETE;
constexpr SensorState_EnumStateType SensorState::FINE_ZERO;
constexpr SensorState_EnumStateType SensorState::FINE_ZERO_COMPLETE;
constexpr SensorState_EnumStateType SensorState::EnumStateType_MIN;
constexpr SensorState_EnumStateType SensorState::EnumStateType_MAX;
constexpr int SensorState::EnumStateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusPacket_EnumStatusType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_net_2dprotocol_2eproto);
  return file_level_enum_descriptors_net_2dprotocol_2eproto[4];
}
bool StatusPacket_EnumStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr StatusPacket_EnumStatusType StatusPacket::STATUS;
constexpr StatusPacket_EnumStatusType StatusPacket::PROGRESS;
constexpr StatusPacket_EnumStatusType StatusPacket::SENSOR_STATUS;
constexpr StatusPacket_EnumStatusType StatusPacket::SENSOR_CONFIG;
constexpr StatusPacket_EnumStatusType StatusPacket::SENSOR_LED;
constexpr StatusPacket_EnumStatusType StatusPacket::SENSOR_STATE;
constexpr StatusPacket_EnumStatusType StatusPacket::SENSOR_FIELD;
constexpr StatusPacket_EnumStatusType StatusPacket::SYSTEM_STATUS;
constexpr StatusPacket_EnumStatusType StatusPacket::COMPLETE_SYSTEM_STATUS;
constexpr StatusPacket_EnumStatusType StatusPacket::EnumStatusType_MIN;
constexpr StatusPacket_EnumStatusType StatusPacket::EnumStatusType_MAX;
constexpr int StatusPacket::EnumStatusType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusPacket_EnumSystemStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_net_2dprotocol_2eproto);
  return file_level_enum_descriptors_net_2dprotocol_2eproto[5];
}
bool StatusPacket_EnumSystemStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr StatusPacket_EnumSystemStatus StatusPacket::STARTUP;
constexpr StatusPacket_EnumSystemStatus StatusPacket::FLASHING;
constexpr StatusPacket_EnumSystemStatus StatusPacket::RUNNING;
constexpr StatusPacket_EnumSystemStatus StatusPacket::MENDER_UPDATE_FAIL;
constexpr StatusPacket_EnumSystemStatus StatusPacket::FPGA_UPDATE_FAIL;
constexpr StatusPacket_EnumSystemStatus StatusPacket::PENDING_COMMIT;
constexpr StatusPacket_EnumSystemStatus StatusPacket::STARTUP_ERROR;
constexpr StatusPacket_EnumSystemStatus StatusPacket::EnumSystemStatus_MIN;
constexpr StatusPacket_EnumSystemStatus StatusPacket::EnumSystemStatus_MAX;
constexpr int StatusPacket::EnumSystemStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

class DataFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<DataFrame>()._has_bits_);
  static void set_has_sensor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_datatype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_val(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

DataFrame::DataFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:DataFrame)
}
DataFrame::DataFrame(const DataFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sensor_, &from.sensor_,
    static_cast<size_t>(reinterpret_cast<char*>(&val_) -
    reinterpret_cast<char*>(&sensor_)) + sizeof(val_));
  // @@protoc_insertion_point(copy_constructor:DataFrame)
}

void DataFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sensor_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&val_) -
    reinterpret_cast<char*>(&sensor_)) + sizeof(val_));
}

DataFrame::~DataFrame() {
  // @@protoc_insertion_point(destructor:DataFrame)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void DataFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DataFrame::ArenaDtor(void* object) {
  DataFrame* _this = reinterpret_cast< DataFrame* >(object);
  (void)_this;
}
void DataFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DataFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DataFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:DataFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&sensor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&val_) -
        reinterpret_cast<char*>(&sensor_)) + sizeof(val_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 sensor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sensor(&has_bits);
          sensor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 datatype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_datatype(&has_bits);
          datatype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 val = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_val(&has_bits);
          val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DataFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DataFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 sensor = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_sensor(), target);
  }

  // required int32 datatype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_datatype(), target);
  }

  // required int32 val = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DataFrame)
  return target;
}

size_t DataFrame::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DataFrame)
  size_t total_size = 0;

  if (_internal_has_sensor()) {
    // required int32 sensor = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_sensor());
  }

  if (_internal_has_datatype()) {
    // required int32 datatype = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_datatype());
  }

  if (_internal_has_val()) {
    // required int32 val = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_val());
  }

  return total_size;
}
size_t DataFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DataFrame)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 sensor = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_sensor());

    // required int32 datatype = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_datatype());

    // required int32 val = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_val());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataFrame::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DataFrame)
  GOOGLE_DCHECK_NE(&from, this);
  const DataFrame* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DataFrame>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DataFrame)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DataFrame)
    MergeFrom(*source);
  }
}

void DataFrame::MergeFrom(const DataFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DataFrame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sensor_ = from.sensor_;
    }
    if (cached_has_bits & 0x00000002u) {
      datatype_ = from.datatype_;
    }
    if (cached_has_bits & 0x00000004u) {
      val_ = from.val_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DataFrame::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DataFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataFrame::CopyFrom(const DataFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DataFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataFrame::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void DataFrame::InternalSwap(DataFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataFrame, val_)
      + sizeof(DataFrame::val_)
      - PROTOBUF_FIELD_OFFSET(DataFrame, sensor_)>(
          reinterpret_cast<char*>(&sensor_),
          reinterpret_cast<char*>(&other->sensor_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DataFrame::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[0]);
}

// ===================================================================

class DataPacket::_Internal {
 public:
  using HasBits = decltype(std::declval<DataPacket>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chassis_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_sensors(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

DataPacket::DataPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  data_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:DataPacket)
}
DataPacket::DataPacket(const DataPacket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  chassis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_chassis_name()) {
    chassis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_chassis_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_sensors_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(num_sensors_));
  // @@protoc_insertion_point(copy_constructor:DataPacket)
}

void DataPacket::SharedCtor() {
chassis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_sensors_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(num_sensors_));
}

DataPacket::~DataPacket() {
  // @@protoc_insertion_point(destructor:DataPacket)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void DataPacket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  chassis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DataPacket::ArenaDtor(void* object) {
  DataPacket* _this = reinterpret_cast< DataPacket* >(object);
  (void)_this;
}
void DataPacket::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DataPacket::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DataPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:DataPacket)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    chassis_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_sensors_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(num_sensors_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataPacket::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string chassis_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_chassis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "DataPacket.chassis_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 num_sensors = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_sensors(&has_bits);
          num_sensors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .DataFrame data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DataPacket::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DataPacket)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 timestamp = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_timestamp(), target);
  }

  // required string chassis_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_chassis_name().data(), static_cast<int>(this->_internal_chassis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "DataPacket.chassis_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chassis_name(), target);
  }

  // required int32 num_sensors = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_sensors(), target);
  }

  // repeated .DataFrame data = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_data_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_data(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DataPacket)
  return target;
}

size_t DataPacket::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DataPacket)
  size_t total_size = 0;

  if (_internal_has_chassis_name()) {
    // required string chassis_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chassis_name());
  }

  if (_internal_has_timestamp()) {
    // required uint32 timestamp = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_timestamp());
  }

  if (_internal_has_num_sensors()) {
    // required int32 num_sensors = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_num_sensors());
  }

  return total_size;
}
size_t DataPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DataPacket)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string chassis_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chassis_name());

    // required uint32 timestamp = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_timestamp());

    // required int32 num_sensors = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_num_sensors());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .DataFrame data = 4;
  total_size += 1UL * this->_internal_data_size();
  for (const auto& msg : this->data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataPacket::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DataPacket)
  GOOGLE_DCHECK_NE(&from, this);
  const DataPacket* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DataPacket>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DataPacket)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DataPacket)
    MergeFrom(*source);
  }
}

void DataPacket::MergeFrom(const DataPacket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DataPacket)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_chassis_name(from._internal_chassis_name());
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_sensors_ = from.num_sensors_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DataPacket::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DataPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataPacket::CopyFrom(const DataPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DataPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataPacket::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(data_)) return false;
  return true;
}

void DataPacket::InternalSwap(DataPacket* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.InternalSwap(&other->data_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &chassis_name_, GetArenaForAllocation(),
      &other->chassis_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataPacket, num_sensors_)
      + sizeof(DataPacket::num_sensors_)
      - PROTOBUF_FIELD_OFFSET(DataPacket, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DataPacket::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[1]);
}

// ===================================================================

class RawCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<RawCommand>()._has_bits_);
  static void set_has_all_sensors(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sensor_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_register_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

RawCommand::RawCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:RawCommand)
}
RawCommand::RawCommand(const RawCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&all_sensors_, &from.all_sensors_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_) -
    reinterpret_cast<char*>(&all_sensors_)) + sizeof(data_));
  // @@protoc_insertion_point(copy_constructor:RawCommand)
}

void RawCommand::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&all_sensors_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&data_) -
    reinterpret_cast<char*>(&all_sensors_)) + sizeof(data_));
}

RawCommand::~RawCommand() {
  // @@protoc_insertion_point(destructor:RawCommand)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RawCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RawCommand::ArenaDtor(void* object) {
  RawCommand* _this = reinterpret_cast< RawCommand* >(object);
  (void)_this;
}
void RawCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RawCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RawCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:RawCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&all_sensors_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&data_) -
        reinterpret_cast<char*>(&all_sensors_)) + sizeof(data_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RawCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool all_sensors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_all_sensors(&has_bits);
          all_sensors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 sensor_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_sensor_num(&has_bits);
          sensor_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 register_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_register_address(&has_bits);
          register_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_data(&has_bits);
          data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RawCommand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RawCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool all_sensors = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_all_sensors(), target);
  }

  // required uint32 sensor_num = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sensor_num(), target);
  }

  // required uint32 register_address = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_register_address(), target);
  }

  // required uint32 data = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RawCommand)
  return target;
}

size_t RawCommand::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RawCommand)
  size_t total_size = 0;

  if (_internal_has_all_sensors()) {
    // required bool all_sensors = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_sensor_num()) {
    // required uint32 sensor_num = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_sensor_num());
  }

  if (_internal_has_register_address()) {
    // required uint32 register_address = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_register_address());
  }

  if (_internal_has_data()) {
    // required uint32 data = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_data());
  }

  return total_size;
}
size_t RawCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RawCommand)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bool all_sensors = 1;
    total_size += 1 + 1;

    // required uint32 sensor_num = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_sensor_num());

    // required uint32 register_address = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_register_address());

    // required uint32 data = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_data());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RawCommand::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RawCommand)
  GOOGLE_DCHECK_NE(&from, this);
  const RawCommand* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RawCommand>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RawCommand)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RawCommand)
    MergeFrom(*source);
  }
}

void RawCommand::MergeFrom(const RawCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RawCommand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      all_sensors_ = from.all_sensors_;
    }
    if (cached_has_bits & 0x00000002u) {
      sensor_num_ = from.sensor_num_;
    }
    if (cached_has_bits & 0x00000004u) {
      register_address_ = from.register_address_;
    }
    if (cached_has_bits & 0x00000008u) {
      data_ = from.data_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RawCommand::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RawCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawCommand::CopyFrom(const RawCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RawCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawCommand::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RawCommand::InternalSwap(RawCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RawCommand, data_)
      + sizeof(RawCommand::data_)
      - PROTOBUF_FIELD_OFFSET(RawCommand, all_sensors_)>(
          reinterpret_cast<char*>(&all_sensors_),
          reinterpret_cast<char*>(&other->all_sensors_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RawCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[2]);
}

// ===================================================================

class DevModeValidation::_Internal {
 public:
  using HasBits = decltype(std::declval<DevModeValidation>()._has_bits_);
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

DevModeValidation::DevModeValidation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:DevModeValidation)
}
DevModeValidation::DevModeValidation(const DevModeValidation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  ::memcpy(&valid_, &from.valid_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_) -
    reinterpret_cast<char*>(&valid_)) + sizeof(enable_));
  // @@protoc_insertion_point(copy_constructor:DevModeValidation)
}

void DevModeValidation::SharedCtor() {
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&valid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&enable_) -
    reinterpret_cast<char*>(&valid_)) + sizeof(enable_));
}

DevModeValidation::~DevModeValidation() {
  // @@protoc_insertion_point(destructor:DevModeValidation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void DevModeValidation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DevModeValidation::ArenaDtor(void* object) {
  DevModeValidation* _this = reinterpret_cast< DevModeValidation* >(object);
  (void)_this;
}
void DevModeValidation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DevModeValidation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DevModeValidation::Clear() {
// @@protoc_insertion_point(message_clear_start:DevModeValidation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    password_.ClearNonDefaultToEmpty();
  }
  ::memset(&valid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&enable_) -
      reinterpret_cast<char*>(&valid_)) + sizeof(enable_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DevModeValidation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string password = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "DevModeValidation.password");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool valid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_valid(&has_bits);
          valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool enable = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_enable(&has_bits);
          enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DevModeValidation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DevModeValidation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string password = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "DevModeValidation.password");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_password(), target);
  }

  // optional bool valid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_valid(), target);
  }

  // optional bool enable = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_enable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DevModeValidation)
  return target;
}

size_t DevModeValidation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DevModeValidation)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string password = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional bool valid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool enable = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevModeValidation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DevModeValidation)
  GOOGLE_DCHECK_NE(&from, this);
  const DevModeValidation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DevModeValidation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DevModeValidation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DevModeValidation)
    MergeFrom(*source);
  }
}

void DevModeValidation::MergeFrom(const DevModeValidation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DevModeValidation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000002u) {
      valid_ = from.valid_;
    }
    if (cached_has_bits & 0x00000004u) {
      enable_ = from.enable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DevModeValidation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DevModeValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DevModeValidation::CopyFrom(const DevModeValidation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DevModeValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevModeValidation::IsInitialized() const {
  return true;
}

void DevModeValidation::InternalSwap(DevModeValidation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, GetArenaForAllocation(),
      &other->password_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DevModeValidation, enable_)
      + sizeof(DevModeValidation::enable_)
      - PROTOBUF_FIELD_OFFSET(DevModeValidation, valid_)>(
          reinterpret_cast<char*>(&valid_),
          reinterpret_cast<char*>(&other->valid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DevModeValidation::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[3]);
}

// ===================================================================

class ConfigMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigMessage>()._has_bits_);
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_datatype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_freq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ConfigMessage::ConfigMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:ConfigMessage)
}
ConfigMessage::ConfigMessage(const ConfigMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sensor_id_, &from.sensor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&freq_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(freq_));
  // @@protoc_insertion_point(copy_constructor:ConfigMessage)
}

void ConfigMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sensor_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&freq_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(freq_));
}

ConfigMessage::~ConfigMessage() {
  // @@protoc_insertion_point(destructor:ConfigMessage)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ConfigMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConfigMessage::ArenaDtor(void* object) {
  ConfigMessage* _this = reinterpret_cast< ConfigMessage* >(object);
  (void)_this;
}
void ConfigMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConfigMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ConfigMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&sensor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&freq_) -
        reinterpret_cast<char*>(&sensor_id_)) + sizeof(freq_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sensor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sensor_id(&has_bits);
          sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 datatype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_datatype(&has_bits);
          datatype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 freq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_freq(&has_bits);
          freq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ConfigMessage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ConfigMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sensor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sensor_id(), target);
  }

  // optional uint32 datatype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_datatype(), target);
  }

  // optional uint32 freq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_freq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ConfigMessage)
  return target;
}

size_t ConfigMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ConfigMessage)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 sensor_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_sensor_id());
    }

    // optional uint32 datatype = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_datatype());
    }

    // optional uint32 freq = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_freq());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfigMessage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ConfigMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const ConfigMessage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ConfigMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ConfigMessage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ConfigMessage)
    MergeFrom(*source);
  }
}

void ConfigMessage::MergeFrom(const ConfigMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ConfigMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sensor_id_ = from.sensor_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      datatype_ = from.datatype_;
    }
    if (cached_has_bits & 0x00000004u) {
      freq_ = from.freq_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ConfigMessage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ConfigMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConfigMessage::CopyFrom(const ConfigMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ConfigMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigMessage::IsInitialized() const {
  return true;
}

void ConfigMessage::InternalSwap(ConfigMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigMessage, freq_)
      + sizeof(ConfigMessage::freq_)
      - PROTOBUF_FIELD_OFFSET(ConfigMessage, sensor_id_)>(
          reinterpret_cast<char*>(&sensor_id_),
          reinterpret_cast<char*>(&other->sensor_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[4]);
}

// ===================================================================

class LogicMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<LogicMessage>()._has_bits_);
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LogicMessage::LogicMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  sensor_list_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:LogicMessage)
}
LogicMessage::LogicMessage(const LogicMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      sensor_list_(from.sensor_list_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sensor_id_, &from.sensor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:LogicMessage)
}

void LogicMessage::SharedCtor() {
sensor_id_ = 0u;
type_ = 1;
}

LogicMessage::~LogicMessage() {
  // @@protoc_insertion_point(destructor:LogicMessage)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LogicMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogicMessage::ArenaDtor(void* object) {
  LogicMessage* _this = reinterpret_cast< LogicMessage* >(object);
  (void)_this;
}
void LogicMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogicMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogicMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:LogicMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sensor_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    sensor_id_ = 0u;
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogicMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sensor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sensor_id(&has_bits);
          sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .LogicMessage.EnumLogicType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::LogicMessage_EnumLogicType_IsValid(val))) {
            _internal_set_type(static_cast<::LogicMessage_EnumLogicType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated uint32 sensor_list = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_sensor_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_sensor_list(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LogicMessage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LogicMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sensor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sensor_id(), target);
  }

  // optional .LogicMessage.EnumLogicType type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // repeated uint32 sensor_list = 3;
  for (int i = 0, n = this->_internal_sensor_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sensor_list(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LogicMessage)
  return target;
}

size_t LogicMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LogicMessage)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 sensor_list = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->sensor_list_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_sensor_list_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 sensor_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_sensor_id());
    }

    // optional .LogicMessage.EnumLogicType type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicMessage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:LogicMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const LogicMessage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LogicMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:LogicMessage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:LogicMessage)
    MergeFrom(*source);
  }
}

void LogicMessage::MergeFrom(const LogicMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LogicMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sensor_list_.MergeFrom(from.sensor_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sensor_id_ = from.sensor_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LogicMessage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:LogicMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicMessage::CopyFrom(const LogicMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LogicMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicMessage::IsInitialized() const {
  return true;
}

void LogicMessage::InternalSwap(LogicMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sensor_list_.InternalSwap(&other->sensor_list_);
  swap(sensor_id_, other->sensor_id_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LogicMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[5]);
}

// ===================================================================

class LogicInterruptMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<LogicInterruptMessage>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LogicInterruptMessage::LogicInterruptMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  sensor_list_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:LogicInterruptMessage)
}
LogicInterruptMessage::LogicInterruptMessage(const LogicInterruptMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      sensor_list_(from.sensor_list_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:LogicInterruptMessage)
}

void LogicInterruptMessage::SharedCtor() {
type_ = 0u;
}

LogicInterruptMessage::~LogicInterruptMessage() {
  // @@protoc_insertion_point(destructor:LogicInterruptMessage)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LogicInterruptMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LogicInterruptMessage::ArenaDtor(void* object) {
  LogicInterruptMessage* _this = reinterpret_cast< LogicInterruptMessage* >(object);
  (void)_this;
}
void LogicInterruptMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogicInterruptMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogicInterruptMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:LogicInterruptMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sensor_list_.Clear();
  type_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogicInterruptMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 sensor_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_sensor_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_sensor_list(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LogicInterruptMessage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LogicInterruptMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // repeated uint32 sensor_list = 2;
  for (int i = 0, n = this->_internal_sensor_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sensor_list(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LogicInterruptMessage)
  return target;
}

size_t LogicInterruptMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LogicInterruptMessage)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 sensor_list = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->sensor_list_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_sensor_list_size());
    total_size += data_size;
  }

  // optional uint32 type = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogicInterruptMessage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:LogicInterruptMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const LogicInterruptMessage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LogicInterruptMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:LogicInterruptMessage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:LogicInterruptMessage)
    MergeFrom(*source);
  }
}

void LogicInterruptMessage::MergeFrom(const LogicInterruptMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LogicInterruptMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sensor_list_.MergeFrom(from.sensor_list_);
  if (from._internal_has_type()) {
    _internal_set_type(from._internal_type());
  }
}

void LogicInterruptMessage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:LogicInterruptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicInterruptMessage::CopyFrom(const LogicInterruptMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LogicInterruptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicInterruptMessage::IsInitialized() const {
  return true;
}

void LogicInterruptMessage::InternalSwap(LogicInterruptMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sensor_list_.InternalSwap(&other->sensor_list_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LogicInterruptMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[6]);
}

// ===================================================================

class WaveMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<WaveMessage>()._has_bits_);
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_freq(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_amp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

WaveMessage::WaveMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:WaveMessage)
}
WaveMessage::WaveMessage(const WaveMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sensor_id_, &from.sensor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:WaveMessage)
}

void WaveMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sensor_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(type_));
}

WaveMessage::~WaveMessage() {
  // @@protoc_insertion_point(destructor:WaveMessage)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void WaveMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WaveMessage::ArenaDtor(void* object) {
  WaveMessage* _this = reinterpret_cast< WaveMessage* >(object);
  (void)_this;
}
void WaveMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WaveMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WaveMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:WaveMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&sensor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&sensor_id_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WaveMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sensor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sensor_id(&has_bits);
          sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float freq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_freq(&has_bits);
          freq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float amp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_amp(&has_bits);
          amp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* WaveMessage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:WaveMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sensor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sensor_id(), target);
  }

  // optional float freq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_freq(), target);
  }

  // optional float amp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_amp(), target);
  }

  // optional uint32 type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:WaveMessage)
  return target;
}

size_t WaveMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:WaveMessage)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 sensor_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_sensor_id());
    }

    // optional float freq = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float amp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WaveMessage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:WaveMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const WaveMessage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<WaveMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:WaveMessage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:WaveMessage)
    MergeFrom(*source);
  }
}

void WaveMessage::MergeFrom(const WaveMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:WaveMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      sensor_id_ = from.sensor_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      freq_ = from.freq_;
    }
    if (cached_has_bits & 0x00000004u) {
      amp_ = from.amp_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void WaveMessage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:WaveMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WaveMessage::CopyFrom(const WaveMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:WaveMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaveMessage::IsInitialized() const {
  return true;
}

void WaveMessage::InternalSwap(WaveMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WaveMessage, type_)
      + sizeof(WaveMessage::type_)
      - PROTOBUF_FIELD_OFFSET(WaveMessage, sensor_id_)>(
          reinterpret_cast<char*>(&sensor_id_),
          reinterpret_cast<char*>(&other->sensor_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WaveMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[7]);
}

// ===================================================================

class CmdPacket::_Internal {
 public:
  using HasBits = decltype(std::declval<CmdPacket>()._has_bits_);
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_datatype(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_freq(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::RawCommand& raw_cmd(const CmdPacket* msg);
  static void set_has_raw_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uri(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::DevModeValidation& dev_mode(const CmdPacket* msg);
  static void set_has_dev_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_chassis_ident(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_closed_loop(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_sync_chassis(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000200) ^ 0x00000200) != 0;
  }
};

const ::RawCommand&
CmdPacket::_Internal::raw_cmd(const CmdPacket* msg) {
  return *msg->raw_cmd_;
}
const ::DevModeValidation&
CmdPacket::_Internal::dev_mode(const CmdPacket* msg) {
  return *msg->dev_mode_;
}
CmdPacket::CmdPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  config_list_(arena),
  logic_req_(arena),
  wave_req_(arena),
  logic_interrupt_req_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CmdPacket)
}
CmdPacket::CmdPacket(const CmdPacket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      config_list_(from.config_list_),
      logic_req_(from.logic_req_),
      wave_req_(from.wave_req_),
      logic_interrupt_req_(from.logic_interrupt_req_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_uri()) {
    uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_uri(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_raw_cmd()) {
    raw_cmd_ = new ::RawCommand(*from.raw_cmd_);
  } else {
    raw_cmd_ = nullptr;
  }
  if (from._internal_has_dev_mode()) {
    dev_mode_ = new ::DevModeValidation(*from.dev_mode_);
  } else {
    dev_mode_ = nullptr;
  }
  ::memcpy(&sensor_id_, &from.sensor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&cmd_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(cmd_));
  // @@protoc_insertion_point(copy_constructor:CmdPacket)
}

void CmdPacket::SharedCtor() {
uri_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&raw_cmd_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_sync_chassis_) -
    reinterpret_cast<char*>(&raw_cmd_)) + sizeof(num_sync_chassis_));
cmd_ = 2;
}

CmdPacket::~CmdPacket() {
  // @@protoc_insertion_point(destructor:CmdPacket)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CmdPacket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  uri_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete raw_cmd_;
  if (this != internal_default_instance()) delete dev_mode_;
}

void CmdPacket::ArenaDtor(void* object) {
  CmdPacket* _this = reinterpret_cast< CmdPacket* >(object);
  (void)_this;
}
void CmdPacket::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CmdPacket::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CmdPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:CmdPacket)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  config_list_.Clear();
  logic_req_.Clear();
  wave_req_.Clear();
  logic_interrupt_req_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      uri_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(raw_cmd_ != nullptr);
      raw_cmd_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(dev_mode_ != nullptr);
      dev_mode_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&sensor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&closed_loop_) -
        reinterpret_cast<char*>(&sensor_id_)) + sizeof(closed_loop_));
  }
  if (cached_has_bits & 0x00000300u) {
    num_sync_chassis_ = 0u;
    cmd_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CmdPacket::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .CmdPacket.EnumCmdType cmd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CmdPacket_EnumCmdType_IsValid(val))) {
            _internal_set_cmd(static_cast<::CmdPacket_EnumCmdType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 sensor_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_sensor_id(&has_bits);
          sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 datatype = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_datatype(&has_bits);
          datatype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 freq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_freq(&has_bits);
          freq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .RawCommand raw_cmd = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw_cmd(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string uri = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_uri();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CmdPacket.uri");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .ConfigMessage config_list = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_config_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .DevModeValidation dev_mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_dev_mode(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .LogicMessage logic_req = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_logic_req(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .WaveMessage wave_req = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_wave_req(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool chassis_ident = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_chassis_ident(&has_bits);
          chassis_ident_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool closed_loop = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_closed_loop(&has_bits);
          closed_loop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .LogicInterruptMessage logic_interrupt_req = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_logic_interrupt_req(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 num_sync_chassis = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_num_sync_chassis(&has_bits);
          num_sync_chassis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CmdPacket::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CmdPacket)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .CmdPacket.EnumCmdType cmd = 1;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_cmd(), target);
  }

  // optional uint32 sensor_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sensor_id(), target);
  }

  // optional uint32 datatype = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_datatype(), target);
  }

  // optional uint32 freq = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_freq(), target);
  }

  // optional .RawCommand raw_cmd = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::raw_cmd(this), target, stream);
  }

  // optional string uri = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_uri().data(), static_cast<int>(this->_internal_uri().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CmdPacket.uri");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_uri(), target);
  }

  // repeated .ConfigMessage config_list = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_config_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_config_list(i), target, stream);
  }

  // optional .DevModeValidation dev_mode = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::dev_mode(this), target, stream);
  }

  // repeated .LogicMessage logic_req = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_logic_req_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_logic_req(i), target, stream);
  }

  // repeated .WaveMessage wave_req = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_wave_req_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_wave_req(i), target, stream);
  }

  // optional bool chassis_ident = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_chassis_ident(), target);
  }

  // optional bool closed_loop = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_closed_loop(), target);
  }

  // repeated .LogicInterruptMessage logic_interrupt_req = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_logic_interrupt_req_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, this->_internal_logic_interrupt_req(i), target, stream);
  }

  // optional uint32 num_sync_chassis = 14;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->_internal_num_sync_chassis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CmdPacket)
  return target;
}

size_t CmdPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CmdPacket)
  size_t total_size = 0;

  // required .CmdPacket.EnumCmdType cmd = 1;
  if (_internal_has_cmd()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cmd());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ConfigMessage config_list = 7;
  total_size += 1UL * this->_internal_config_list_size();
  for (const auto& msg : this->config_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .LogicMessage logic_req = 9;
  total_size += 1UL * this->_internal_logic_req_size();
  for (const auto& msg : this->logic_req_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .WaveMessage wave_req = 10;
  total_size += 1UL * this->_internal_wave_req_size();
  for (const auto& msg : this->wave_req_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .LogicInterruptMessage logic_interrupt_req = 13;
  total_size += 1UL * this->_internal_logic_interrupt_req_size();
  for (const auto& msg : this->logic_interrupt_req_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string uri = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_uri());
    }

    // optional .RawCommand raw_cmd = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *raw_cmd_);
    }

    // optional .DevModeValidation dev_mode = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dev_mode_);
    }

    // optional uint32 sensor_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_sensor_id());
    }

    // optional uint32 datatype = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_datatype());
    }

    // optional uint32 freq = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_freq());
    }

    // optional bool chassis_ident = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool closed_loop = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional uint32 num_sync_chassis = 14;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_num_sync_chassis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CmdPacket::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CmdPacket)
  GOOGLE_DCHECK_NE(&from, this);
  const CmdPacket* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CmdPacket>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CmdPacket)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CmdPacket)
    MergeFrom(*source);
  }
}

void CmdPacket::MergeFrom(const CmdPacket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CmdPacket)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  config_list_.MergeFrom(from.config_list_);
  logic_req_.MergeFrom(from.logic_req_);
  wave_req_.MergeFrom(from.wave_req_);
  logic_interrupt_req_.MergeFrom(from.logic_interrupt_req_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_uri(from._internal_uri());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_raw_cmd()->::RawCommand::MergeFrom(from._internal_raw_cmd());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_dev_mode()->::DevModeValidation::MergeFrom(from._internal_dev_mode());
    }
    if (cached_has_bits & 0x00000008u) {
      sensor_id_ = from.sensor_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      datatype_ = from.datatype_;
    }
    if (cached_has_bits & 0x00000020u) {
      freq_ = from.freq_;
    }
    if (cached_has_bits & 0x00000040u) {
      chassis_ident_ = from.chassis_ident_;
    }
    if (cached_has_bits & 0x00000080u) {
      closed_loop_ = from.closed_loop_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      num_sync_chassis_ = from.num_sync_chassis_;
    }
    if (cached_has_bits & 0x00000200u) {
      cmd_ = from.cmd_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CmdPacket::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CmdPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CmdPacket::CopyFrom(const CmdPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CmdPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CmdPacket::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_raw_cmd()) {
    if (!raw_cmd_->IsInitialized()) return false;
  }
  return true;
}

void CmdPacket::InternalSwap(CmdPacket* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  config_list_.InternalSwap(&other->config_list_);
  logic_req_.InternalSwap(&other->logic_req_);
  wave_req_.InternalSwap(&other->wave_req_);
  logic_interrupt_req_.InternalSwap(&other->logic_interrupt_req_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &uri_, GetArenaForAllocation(),
      &other->uri_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CmdPacket, num_sync_chassis_)
      + sizeof(CmdPacket::num_sync_chassis_)
      - PROTOBUF_FIELD_OFFSET(CmdPacket, raw_cmd_)>(
          reinterpret_cast<char*>(&raw_cmd_),
          reinterpret_cast<char*>(&other->raw_cmd_));
  swap(cmd_, other->cmd_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CmdPacket::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[8]);
}

// ===================================================================

class SensorStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<SensorStatus>()._has_bits_);
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sensor_card_serial_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sensor_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sensor_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sensor_serial_num(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

SensorStatus::SensorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:SensorStatus)
}
SensorStatus::SensorStatus(const SensorStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sensor_card_serial_num_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sensor_card_serial_num()) {
    sensor_card_serial_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sensor_card_serial_num(), 
      GetArenaForAllocation());
  }
  sensor_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sensor_version()) {
    sensor_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sensor_version(), 
      GetArenaForAllocation());
  }
  sensor_serial_num_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sensor_serial_num()) {
    sensor_serial_num_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sensor_serial_num(), 
      GetArenaForAllocation());
  }
  ::memcpy(&sensor_id_, &from.sensor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&sensor_connected_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(sensor_connected_));
  // @@protoc_insertion_point(copy_constructor:SensorStatus)
}

void SensorStatus::SharedCtor() {
sensor_card_serial_num_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
sensor_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
sensor_serial_num_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sensor_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sensor_connected_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(sensor_connected_));
}

SensorStatus::~SensorStatus() {
  // @@protoc_insertion_point(destructor:SensorStatus)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SensorStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sensor_card_serial_num_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sensor_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sensor_serial_num_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SensorStatus::ArenaDtor(void* object) {
  SensorStatus* _this = reinterpret_cast< SensorStatus* >(object);
  (void)_this;
}
void SensorStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SensorStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SensorStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sensor_card_serial_num_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sensor_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      sensor_serial_num_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&sensor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sensor_connected_) -
        reinterpret_cast<char*>(&sensor_id_)) + sizeof(sensor_connected_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 sensor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sensor_id(&has_bits);
          sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string sensor_card_serial_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_sensor_card_serial_num();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SensorStatus.sensor_card_serial_num");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string sensor_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_sensor_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SensorStatus.sensor_version");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool sensor_connected = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_sensor_connected(&has_bits);
          sensor_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string sensor_serial_num = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_sensor_serial_num();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SensorStatus.sensor_serial_num");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SensorStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 sensor_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sensor_id(), target);
  }

  // optional string sensor_card_serial_num = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sensor_card_serial_num().data(), static_cast<int>(this->_internal_sensor_card_serial_num().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SensorStatus.sensor_card_serial_num");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sensor_card_serial_num(), target);
  }

  // optional string sensor_version = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sensor_version().data(), static_cast<int>(this->_internal_sensor_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SensorStatus.sensor_version");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sensor_version(), target);
  }

  // optional bool sensor_connected = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_sensor_connected(), target);
  }

  // optional string sensor_serial_num = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sensor_serial_num().data(), static_cast<int>(this->_internal_sensor_serial_num().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SensorStatus.sensor_serial_num");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_sensor_serial_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorStatus)
  return target;
}

size_t SensorStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorStatus)
  size_t total_size = 0;

  // required uint32 sensor_id = 1;
  if (_internal_has_sensor_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_sensor_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string sensor_card_serial_num = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sensor_card_serial_num());
    }

    // optional string sensor_version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sensor_version());
    }

    // optional string sensor_serial_num = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sensor_serial_num());
    }

  }
  // optional bool sensor_connected = 4;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SensorStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SensorStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const SensorStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SensorStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SensorStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SensorStatus)
    MergeFrom(*source);
  }
}

void SensorStatus::MergeFrom(const SensorStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SensorStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sensor_card_serial_num(from._internal_sensor_card_serial_num());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sensor_version(from._internal_sensor_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_sensor_serial_num(from._internal_sensor_serial_num());
    }
    if (cached_has_bits & 0x00000008u) {
      sensor_id_ = from.sensor_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      sensor_connected_ = from.sensor_connected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SensorStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SensorStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorStatus::CopyFrom(const SensorStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SensorStatus::InternalSwap(SensorStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sensor_card_serial_num_, GetArenaForAllocation(),
      &other->sensor_card_serial_num_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sensor_version_, GetArenaForAllocation(),
      &other->sensor_version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sensor_serial_num_, GetArenaForAllocation(),
      &other->sensor_serial_num_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorStatus, sensor_connected_)
      + sizeof(SensorStatus::sensor_connected_)
      - PROTOBUF_FIELD_OFFSET(SensorStatus, sensor_id_)>(
          reinterpret_cast<char*>(&sensor_id_),
          reinterpret_cast<char*>(&other->sensor_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[9]);
}

// ===================================================================

class SensorState::_Internal {
 public:
  using HasBits = decltype(std::declval<SensorState>()._has_bits_);
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SensorState::SensorState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:SensorState)
}
SensorState::SensorState(const SensorState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sensor_id_, &from.sensor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_flags_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(error_flags_));
  // @@protoc_insertion_point(copy_constructor:SensorState)
}

void SensorState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sensor_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_flags_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(error_flags_));
}

SensorState::~SensorState() {
  // @@protoc_insertion_point(destructor:SensorState)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SensorState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SensorState::ArenaDtor(void* object) {
  SensorState* _this = reinterpret_cast< SensorState* >(object);
  (void)_this;
}
void SensorState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SensorState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SensorState::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&sensor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&error_flags_) -
        reinterpret_cast<char*>(&sensor_id_)) + sizeof(error_flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sensor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sensor_id(&has_bits);
          sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorState.EnumStateType state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SensorState_EnumStateType_IsValid(val))) {
            _internal_set_state(static_cast<::SensorState_EnumStateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 error_flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_error_flags(&has_bits);
          error_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SensorState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sensor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sensor_id(), target);
  }

  // optional .SensorState.EnumStateType state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_state(), target);
  }

  // optional uint32 error_flags = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_error_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorState)
  return target;
}

size_t SensorState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorState)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 sensor_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_sensor_id());
    }

    // optional .SensorState.EnumStateType state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional uint32 error_flags = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_error_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SensorState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SensorState)
  GOOGLE_DCHECK_NE(&from, this);
  const SensorState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SensorState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SensorState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SensorState)
    MergeFrom(*source);
  }
}

void SensorState::MergeFrom(const SensorState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SensorState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sensor_id_ = from.sensor_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      state_ = from.state_;
    }
    if (cached_has_bits & 0x00000004u) {
      error_flags_ = from.error_flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SensorState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SensorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorState::CopyFrom(const SensorState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorState::IsInitialized() const {
  return true;
}

void SensorState::InternalSwap(SensorState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorState, error_flags_)
      + sizeof(SensorState::error_flags_)
      - PROTOBUF_FIELD_OFFSET(SensorState, sensor_id_)>(
          reinterpret_cast<char*>(&sensor_id_),
          reinterpret_cast<char*>(&other->sensor_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[10]);
}

// ===================================================================

class SensorConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<SensorConfig>()._has_bits_);
  static void set_has_sensor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_datatype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_freq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_calibration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

SensorConfig::SensorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:SensorConfig)
}
SensorConfig::SensorConfig(const SensorConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sensor_, &from.sensor_,
    static_cast<size_t>(reinterpret_cast<char*>(&calibration_) -
    reinterpret_cast<char*>(&sensor_)) + sizeof(calibration_));
  // @@protoc_insertion_point(copy_constructor:SensorConfig)
}

void SensorConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sensor_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&calibration_) -
    reinterpret_cast<char*>(&sensor_)) + sizeof(calibration_));
}

SensorConfig::~SensorConfig() {
  // @@protoc_insertion_point(destructor:SensorConfig)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SensorConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SensorConfig::ArenaDtor(void* object) {
  SensorConfig* _this = reinterpret_cast< SensorConfig* >(object);
  (void)_this;
}
void SensorConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SensorConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SensorConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&sensor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&calibration_) -
        reinterpret_cast<char*>(&sensor_)) + sizeof(calibration_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 sensor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sensor(&has_bits);
          sensor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 datatype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_datatype(&has_bits);
          datatype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 freq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_freq(&has_bits);
          freq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float calibration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_calibration(&has_bits);
          calibration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SensorConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 sensor = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sensor(), target);
  }

  // required uint32 datatype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_datatype(), target);
  }

  // required uint32 freq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_freq(), target);
  }

  // optional float calibration = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_calibration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorConfig)
  return target;
}

size_t SensorConfig::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:SensorConfig)
  size_t total_size = 0;

  if (_internal_has_sensor()) {
    // required uint32 sensor = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_sensor());
  }

  if (_internal_has_datatype()) {
    // required uint32 datatype = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_datatype());
  }

  if (_internal_has_freq()) {
    // required uint32 freq = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_freq());
  }

  return total_size;
}
size_t SensorConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorConfig)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 sensor = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_sensor());

    // required uint32 datatype = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_datatype());

    // required uint32 freq = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_freq());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float calibration = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SensorConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SensorConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const SensorConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SensorConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SensorConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SensorConfig)
    MergeFrom(*source);
  }
}

void SensorConfig::MergeFrom(const SensorConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SensorConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      sensor_ = from.sensor_;
    }
    if (cached_has_bits & 0x00000002u) {
      datatype_ = from.datatype_;
    }
    if (cached_has_bits & 0x00000004u) {
      freq_ = from.freq_;
    }
    if (cached_has_bits & 0x00000008u) {
      calibration_ = from.calibration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SensorConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SensorConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorConfig::CopyFrom(const SensorConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorConfig::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SensorConfig::InternalSwap(SensorConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorConfig, calibration_)
      + sizeof(SensorConfig::calibration_)
      - PROTOBUF_FIELD_OFFSET(SensorConfig, sensor_)>(
          reinterpret_cast<char*>(&sensor_),
          reinterpret_cast<char*>(&other->sensor_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[11]);
}

// ===================================================================

class SensorLed::_Internal {
 public:
  using HasBits = decltype(std::declval<SensorLed>()._has_bits_);
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blink_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SensorLed::SensorLed(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:SensorLed)
}
SensorLed::SensorLed(const SensorLed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sensor_id_, &from.sensor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&color_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(color_));
  // @@protoc_insertion_point(copy_constructor:SensorLed)
}

void SensorLed::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sensor_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&color_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(color_));
}

SensorLed::~SensorLed() {
  // @@protoc_insertion_point(destructor:SensorLed)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SensorLed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SensorLed::ArenaDtor(void* object) {
  SensorLed* _this = reinterpret_cast< SensorLed* >(object);
  (void)_this;
}
void SensorLed::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SensorLed::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SensorLed::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorLed)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&sensor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&color_) -
        reinterpret_cast<char*>(&sensor_id_)) + sizeof(color_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorLed::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sensor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sensor_id(&has_bits);
          sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 blink_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_blink_state(&has_bits);
          blink_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_color(&has_bits);
          color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SensorLed::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorLed)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sensor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sensor_id(), target);
  }

  // optional uint32 blink_state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_blink_state(), target);
  }

  // optional uint32 color = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorLed)
  return target;
}

size_t SensorLed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorLed)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 sensor_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_sensor_id());
    }

    // optional uint32 blink_state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_blink_state());
    }

    // optional uint32 color = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_color());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SensorLed::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SensorLed)
  GOOGLE_DCHECK_NE(&from, this);
  const SensorLed* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SensorLed>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SensorLed)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SensorLed)
    MergeFrom(*source);
  }
}

void SensorLed::MergeFrom(const SensorLed& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SensorLed)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sensor_id_ = from.sensor_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      blink_state_ = from.blink_state_;
    }
    if (cached_has_bits & 0x00000004u) {
      color_ = from.color_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SensorLed::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SensorLed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorLed::CopyFrom(const SensorLed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorLed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorLed::IsInitialized() const {
  return true;
}

void SensorLed::InternalSwap(SensorLed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorLed, color_)
      + sizeof(SensorLed::color_)
      - PROTOBUF_FIELD_OFFSET(SensorLed, sensor_id_)>(
          reinterpret_cast<char*>(&sensor_id_),
          reinterpret_cast<char*>(&other->sensor_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorLed::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[12]);
}

// ===================================================================

class SensorField::_Internal {
 public:
  using HasBits = decltype(std::declval<SensorField>()._has_bits_);
  static void set_has_sensor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_field_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_field_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_field_z(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SensorField::SensorField(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:SensorField)
}
SensorField::SensorField(const SensorField& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sensor_id_, &from.sensor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&field_z_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(field_z_));
  // @@protoc_insertion_point(copy_constructor:SensorField)
}

void SensorField::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sensor_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&field_z_) -
    reinterpret_cast<char*>(&sensor_id_)) + sizeof(field_z_));
}

SensorField::~SensorField() {
  // @@protoc_insertion_point(destructor:SensorField)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SensorField::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SensorField::ArenaDtor(void* object) {
  SensorField* _this = reinterpret_cast< SensorField* >(object);
  (void)_this;
}
void SensorField::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SensorField::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SensorField::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorField)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&sensor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&field_z_) -
        reinterpret_cast<char*>(&sensor_id_)) + sizeof(field_z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorField::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sensor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sensor_id(&has_bits);
          sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float field_x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_field_x(&has_bits);
          field_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float field_y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_field_y(&has_bits);
          field_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float field_z = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_field_z(&has_bits);
          field_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SensorField::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorField)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sensor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sensor_id(), target);
  }

  // optional float field_x = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_field_x(), target);
  }

  // optional float field_y = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_field_y(), target);
  }

  // optional float field_z = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_field_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorField)
  return target;
}

size_t SensorField::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorField)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 sensor_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_sensor_id());
    }

    // optional float field_x = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float field_y = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float field_z = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SensorField::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SensorField)
  GOOGLE_DCHECK_NE(&from, this);
  const SensorField* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SensorField>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SensorField)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SensorField)
    MergeFrom(*source);
  }
}

void SensorField::MergeFrom(const SensorField& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SensorField)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      sensor_id_ = from.sensor_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      field_x_ = from.field_x_;
    }
    if (cached_has_bits & 0x00000004u) {
      field_y_ = from.field_y_;
    }
    if (cached_has_bits & 0x00000008u) {
      field_z_ = from.field_z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SensorField::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SensorField)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorField::CopyFrom(const SensorField& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorField)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorField::IsInitialized() const {
  return true;
}

void SensorField::InternalSwap(SensorField* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorField, field_z_)
      + sizeof(SensorField::field_z_)
      - PROTOBUF_FIELD_OFFSET(SensorField, sensor_id_)>(
          reinterpret_cast<char*>(&sensor_id_),
          reinterpret_cast<char*>(&other->sensor_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorField::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[13]);
}

// ===================================================================

class ChassisStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ChassisStatus>()._has_bits_);
  static void set_has_closed_loop(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChassisStatus::ChassisStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:ChassisStatus)
}
ChassisStatus::ChassisStatus(const ChassisStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  closed_loop_ = from.closed_loop_;
  // @@protoc_insertion_point(copy_constructor:ChassisStatus)
}

void ChassisStatus::SharedCtor() {
closed_loop_ = false;
}

ChassisStatus::~ChassisStatus() {
  // @@protoc_insertion_point(destructor:ChassisStatus)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ChassisStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChassisStatus::ArenaDtor(void* object) {
  ChassisStatus* _this = reinterpret_cast< ChassisStatus* >(object);
  (void)_this;
}
void ChassisStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ChassisStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ChassisStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:ChassisStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  closed_loop_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChassisStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool closed_loop = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_closed_loop(&has_bits);
          closed_loop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ChassisStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ChassisStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool closed_loop = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_closed_loop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ChassisStatus)
  return target;
}

size_t ChassisStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ChassisStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool closed_loop = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChassisStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ChassisStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const ChassisStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ChassisStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ChassisStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ChassisStatus)
    MergeFrom(*source);
  }
}

void ChassisStatus::MergeFrom(const ChassisStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ChassisStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_closed_loop()) {
    _internal_set_closed_loop(from._internal_closed_loop());
  }
}

void ChassisStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ChassisStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChassisStatus::CopyFrom(const ChassisStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ChassisStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChassisStatus::IsInitialized() const {
  return true;
}

void ChassisStatus::InternalSwap(ChassisStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(closed_loop_, other->closed_loop_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChassisStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[14]);
}

// ===================================================================

class SystemStatusMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemStatusMessage>()._has_bits_);
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_total(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_master(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_serial_short(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SystemStatusMessage::SystemStatusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:SystemStatusMessage)
}
SystemStatusMessage::SystemStatusMessage(const SystemStatusMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_version()) {
    version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_version(), 
      GetArenaForAllocation());
  }
  master_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_master()) {
    master_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_master(), 
      GetArenaForAllocation());
  }
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_serial()) {
    serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serial(), 
      GetArenaForAllocation());
  }
  serial_short_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_serial_short()) {
    serial_short_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serial_short(), 
      GetArenaForAllocation());
  }
  ::memcpy(&num_, &from.num_,
    static_cast<size_t>(reinterpret_cast<char*>(&total_) -
    reinterpret_cast<char*>(&num_)) + sizeof(total_));
  // @@protoc_insertion_point(copy_constructor:SystemStatusMessage)
}

void SystemStatusMessage::SharedCtor() {
version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
master_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
serial_short_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&num_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&total_) -
    reinterpret_cast<char*>(&num_)) + sizeof(total_));
}

SystemStatusMessage::~SystemStatusMessage() {
  // @@protoc_insertion_point(destructor:SystemStatusMessage)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SystemStatusMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  master_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_short_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SystemStatusMessage::ArenaDtor(void* object) {
  SystemStatusMessage* _this = reinterpret_cast< SystemStatusMessage* >(object);
  (void)_this;
}
void SystemStatusMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SystemStatusMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemStatusMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:SystemStatusMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      master_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      serial_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      serial_short_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&total_) -
        reinterpret_cast<char*>(&num_)) + sizeof(total_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SystemStatusMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_num(&has_bits);
          num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 total = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_total(&has_bits);
          total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SystemStatusMessage.version");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string master = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_master();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SystemStatusMessage.master");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string serial = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_serial();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SystemStatusMessage.serial");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string serial_short = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_serial_short();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SystemStatusMessage.serial_short");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SystemStatusMessage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SystemStatusMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 num = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num(), target);
  }

  // optional uint32 total = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_total(), target);
  }

  // optional string version = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SystemStatusMessage.version");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_version(), target);
  }

  // optional string master = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_master().data(), static_cast<int>(this->_internal_master().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SystemStatusMessage.master");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_master(), target);
  }

  // optional string serial = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_serial().data(), static_cast<int>(this->_internal_serial().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SystemStatusMessage.serial");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_serial(), target);
  }

  // optional string serial_short = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_serial_short().data(), static_cast<int>(this->_internal_serial_short().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SystemStatusMessage.serial_short");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_serial_short(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SystemStatusMessage)
  return target;
}

size_t SystemStatusMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SystemStatusMessage)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string version = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional string master = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_master());
    }

    // optional string serial = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial());
    }

    // optional string serial_short = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial_short());
    }

    // optional uint32 num = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_num());
    }

    // optional uint32 total = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_total());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemStatusMessage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SystemStatusMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const SystemStatusMessage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SystemStatusMessage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SystemStatusMessage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SystemStatusMessage)
    MergeFrom(*source);
  }
}

void SystemStatusMessage::MergeFrom(const SystemStatusMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SystemStatusMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_master(from._internal_master());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_serial(from._internal_serial());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_serial_short(from._internal_serial_short());
    }
    if (cached_has_bits & 0x00000010u) {
      num_ = from.num_;
    }
    if (cached_has_bits & 0x00000020u) {
      total_ = from.total_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SystemStatusMessage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SystemStatusMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SystemStatusMessage::CopyFrom(const SystemStatusMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SystemStatusMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemStatusMessage::IsInitialized() const {
  return true;
}

void SystemStatusMessage::InternalSwap(SystemStatusMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &version_, GetArenaForAllocation(),
      &other->version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &master_, GetArenaForAllocation(),
      &other->master_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serial_, GetArenaForAllocation(),
      &other->serial_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serial_short_, GetArenaForAllocation(),
      &other->serial_short_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemStatusMessage, total_)
      + sizeof(SystemStatusMessage::total_)
      - PROTOBUF_FIELD_OFFSET(SystemStatusMessage, num_)>(
          reinterpret_cast<char*>(&num_),
          reinterpret_cast<char*>(&other->num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SystemStatusMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[15]);
}

// ===================================================================

class StatusPacket::_Internal {
 public:
  using HasBits = decltype(std::declval<StatusPacket>()._has_bits_);
  static void set_has_chassis_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_sensors(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_progress_msg(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::ChassisStatus& chassis_status(const StatusPacket* msg);
  static void set_has_chassis_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::SystemStatusMessage& system_status(const StatusPacket* msg);
  static void set_has_system_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000163) ^ 0x00000163) != 0;
  }
};

const ::ChassisStatus&
StatusPacket::_Internal::chassis_status(const StatusPacket* msg) {
  return *msg->chassis_status_;
}
const ::SystemStatusMessage&
StatusPacket::_Internal::system_status(const StatusPacket* msg) {
  return *msg->system_status_;
}
StatusPacket::StatusPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  sensor_status_(arena),
  sensor_config_(arena),
  sensor_led_(arena),
  sensor_state_(arena),
  sensor_field_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:StatusPacket)
}
StatusPacket::StatusPacket(const StatusPacket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      sensor_status_(from.sensor_status_),
      sensor_config_(from.sensor_config_),
      sensor_led_(from.sensor_led_),
      sensor_state_(from.sensor_state_),
      sensor_field_(from.sensor_field_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  chassis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_chassis_name()) {
    chassis_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_chassis_name(), 
      GetArenaForAllocation());
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_version()) {
    version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_version(), 
      GetArenaForAllocation());
  }
  progress_msg_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_progress_msg()) {
    progress_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_progress_msg(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_chassis_status()) {
    chassis_status_ = new ::ChassisStatus(*from.chassis_status_);
  } else {
    chassis_status_ = nullptr;
  }
  if (from._internal_has_system_status()) {
    system_status_ = new ::SystemStatusMessage(*from.system_status_);
  } else {
    system_status_ = nullptr;
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&type_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:StatusPacket)
}

void StatusPacket::SharedCtor() {
chassis_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
progress_msg_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&chassis_status_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&chassis_status_)) + sizeof(status_));
}

StatusPacket::~StatusPacket() {
  // @@protoc_insertion_point(destructor:StatusPacket)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StatusPacket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  chassis_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  progress_msg_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete chassis_status_;
  if (this != internal_default_instance()) delete system_status_;
}

void StatusPacket::ArenaDtor(void* object) {
  StatusPacket* _this = reinterpret_cast< StatusPacket* >(object);
  (void)_this;
}
void StatusPacket::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatusPacket::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatusPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:StatusPacket)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sensor_status_.Clear();
  sensor_config_.Clear();
  sensor_led_.Clear();
  sensor_state_.Clear();
  sensor_field_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      chassis_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      progress_msg_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(chassis_status_ != nullptr);
      chassis_status_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(system_status_ != nullptr);
      system_status_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&progress_) -
        reinterpret_cast<char*>(&type_)) + sizeof(progress_));
  }
  status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusPacket::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string chassis_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_chassis_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StatusPacket.chassis_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .StatusPacket.EnumStatusType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::StatusPacket_EnumStatusType_IsValid(val))) {
            _internal_set_type(static_cast<::StatusPacket_EnumStatusType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required uint32 num_sensors = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_sensors(&has_bits);
          num_sensors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SensorStatus sensor_status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sensor_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // required string version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StatusPacket.version");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 progress = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_progress(&has_bits);
          progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string progress_msg = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_progress_msg();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "StatusPacket.progress_msg");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SensorConfig sensor_config = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sensor_config(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // required .StatusPacket.EnumSystemStatus status = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::StatusPacket_EnumSystemStatus_IsValid(val))) {
            _internal_set_status(static_cast<::StatusPacket_EnumSystemStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .SensorLed sensor_led = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sensor_led(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .SensorState sensor_state = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sensor_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .SensorField sensor_field = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sensor_field(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .ChassisStatus chassis_status = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_chassis_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SystemStatusMessage system_status = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_system_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StatusPacket::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StatusPacket)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string chassis_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_chassis_name().data(), static_cast<int>(this->_internal_chassis_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StatusPacket.chassis_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_chassis_name(), target);
  }

  // required .StatusPacket.EnumStatusType type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // required uint32 num_sensors = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_num_sensors(), target);
  }

  // repeated .SensorStatus sensor_status = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sensor_status_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_sensor_status(i), target, stream);
  }

  // required string version = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StatusPacket.version");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_version(), target);
  }

  // optional uint32 progress = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_progress(), target);
  }

  // optional string progress_msg = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_progress_msg().data(), static_cast<int>(this->_internal_progress_msg().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "StatusPacket.progress_msg");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_progress_msg(), target);
  }

  // repeated .SensorConfig sensor_config = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sensor_config_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_sensor_config(i), target, stream);
  }

  // required .StatusPacket.EnumSystemStatus status = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_status(), target);
  }

  // repeated .SensorLed sensor_led = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sensor_led_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_sensor_led(i), target, stream);
  }

  // repeated .SensorState sensor_state = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sensor_state_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_sensor_state(i), target, stream);
  }

  // repeated .SensorField sensor_field = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sensor_field_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, this->_internal_sensor_field(i), target, stream);
  }

  // optional .ChassisStatus chassis_status = 13;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::chassis_status(this), target, stream);
  }

  // optional .SystemStatusMessage system_status = 14;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::system_status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StatusPacket)
  return target;
}

size_t StatusPacket::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StatusPacket)
  size_t total_size = 0;

  if (_internal_has_chassis_name()) {
    // required string chassis_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chassis_name());
  }

  if (_internal_has_version()) {
    // required string version = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  if (_internal_has_type()) {
    // required .StatusPacket.EnumStatusType type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (_internal_has_num_sensors()) {
    // required uint32 num_sensors = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_num_sensors());
  }

  if (_internal_has_status()) {
    // required .StatusPacket.EnumSystemStatus status = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t StatusPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StatusPacket)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000163) ^ 0x00000163) == 0) {  // All required fields are present.
    // required string chassis_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chassis_name());

    // required string version = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());

    // required .StatusPacket.EnumStatusType type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

    // required uint32 num_sensors = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_num_sensors());

    // required .StatusPacket.EnumSystemStatus status = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SensorStatus sensor_status = 4;
  total_size += 1UL * this->_internal_sensor_status_size();
  for (const auto& msg : this->sensor_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SensorConfig sensor_config = 8;
  total_size += 1UL * this->_internal_sensor_config_size();
  for (const auto& msg : this->sensor_config_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SensorLed sensor_led = 10;
  total_size += 1UL * this->_internal_sensor_led_size();
  for (const auto& msg : this->sensor_led_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SensorState sensor_state = 11;
  total_size += 1UL * this->_internal_sensor_state_size();
  for (const auto& msg : this->sensor_state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SensorField sensor_field = 12;
  total_size += 1UL * this->_internal_sensor_field_size();
  for (const auto& msg : this->sensor_field_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001cu) {
    // optional string progress_msg = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_progress_msg());
    }

    // optional .ChassisStatus chassis_status = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chassis_status_);
    }

    // optional .SystemStatusMessage system_status = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *system_status_);
    }

  }
  // optional uint32 progress = 6;
  if (cached_has_bits & 0x00000080u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_progress());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatusPacket::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:StatusPacket)
  GOOGLE_DCHECK_NE(&from, this);
  const StatusPacket* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StatusPacket>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StatusPacket)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:StatusPacket)
    MergeFrom(*source);
  }
}

void StatusPacket::MergeFrom(const StatusPacket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StatusPacket)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sensor_status_.MergeFrom(from.sensor_status_);
  sensor_config_.MergeFrom(from.sensor_config_);
  sensor_led_.MergeFrom(from.sensor_led_);
  sensor_state_.MergeFrom(from.sensor_state_);
  sensor_field_.MergeFrom(from.sensor_field_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_chassis_name(from._internal_chassis_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_progress_msg(from._internal_progress_msg());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_chassis_status()->::ChassisStatus::MergeFrom(from._internal_chassis_status());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_system_status()->::SystemStatusMessage::MergeFrom(from._internal_system_status());
    }
    if (cached_has_bits & 0x00000020u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000040u) {
      num_sensors_ = from.num_sensors_;
    }
    if (cached_has_bits & 0x00000080u) {
      progress_ = from.progress_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_status(from._internal_status());
  }
}

void StatusPacket::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:StatusPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusPacket::CopyFrom(const StatusPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StatusPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusPacket::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(sensor_status_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(sensor_config_)) return false;
  return true;
}

void StatusPacket::InternalSwap(StatusPacket* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sensor_status_.InternalSwap(&other->sensor_status_);
  sensor_config_.InternalSwap(&other->sensor_config_);
  sensor_led_.InternalSwap(&other->sensor_led_);
  sensor_state_.InternalSwap(&other->sensor_state_);
  sensor_field_.InternalSwap(&other->sensor_field_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &chassis_name_, GetArenaForAllocation(),
      &other->chassis_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &version_, GetArenaForAllocation(),
      &other->version_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &progress_msg_, GetArenaForAllocation(),
      &other->progress_msg_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusPacket, status_)
      + sizeof(StatusPacket::status_)
      - PROTOBUF_FIELD_OFFSET(StatusPacket, chassis_status_)>(
          reinterpret_cast<char*>(&chassis_status_),
          reinterpret_cast<char*>(&other->chassis_status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusPacket::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_net_2dprotocol_2eproto_getter, &descriptor_table_net_2dprotocol_2eproto_once,
      file_level_metadata_net_2dprotocol_2eproto[16]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::DataFrame* Arena::CreateMaybeMessage< ::DataFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DataFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::DataPacket* Arena::CreateMaybeMessage< ::DataPacket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DataPacket >(arena);
}
template<> PROTOBUF_NOINLINE ::RawCommand* Arena::CreateMaybeMessage< ::RawCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RawCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::DevModeValidation* Arena::CreateMaybeMessage< ::DevModeValidation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DevModeValidation >(arena);
}
template<> PROTOBUF_NOINLINE ::ConfigMessage* Arena::CreateMaybeMessage< ::ConfigMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ConfigMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::LogicMessage* Arena::CreateMaybeMessage< ::LogicMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LogicMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::LogicInterruptMessage* Arena::CreateMaybeMessage< ::LogicInterruptMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LogicInterruptMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::WaveMessage* Arena::CreateMaybeMessage< ::WaveMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::WaveMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::CmdPacket* Arena::CreateMaybeMessage< ::CmdPacket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CmdPacket >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorStatus* Arena::CreateMaybeMessage< ::SensorStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorState* Arena::CreateMaybeMessage< ::SensorState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorState >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorConfig* Arena::CreateMaybeMessage< ::SensorConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorLed* Arena::CreateMaybeMessage< ::SensorLed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorLed >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorField* Arena::CreateMaybeMessage< ::SensorField >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorField >(arena);
}
template<> PROTOBUF_NOINLINE ::ChassisStatus* Arena::CreateMaybeMessage< ::ChassisStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ChassisStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::SystemStatusMessage* Arena::CreateMaybeMessage< ::SystemStatusMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SystemStatusMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::StatusPacket* Arena::CreateMaybeMessage< ::StatusPacket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StatusPacket >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
